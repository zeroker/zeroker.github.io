{"meta":{"title":"Q同學's world","subtitle":"千里之行，始于足下","description":"Make a diffence","author":"Q-同學","url":"http://yoursite.com"},"pages":[{"title":"categories","date":"2018-05-10T12:56:29.000Z","updated":"2018-05-10T12:56:50.000Z","comments":true,"path":"categories/index.html","permalink":"http://yoursite.com/categories/index.html","excerpt":"","text":""},{"title":"about","date":"2018-05-10T12:57:47.000Z","updated":"2019-08-16T12:58:58.000Z","comments":true,"path":"about/index.html","permalink":"http://yoursite.com/about/index.html","excerpt":"","text":"座右铭： 千里之行，始于足下彩虹山上渐变的爵士， 身上流淌着极简的血液。"},{"title":"tags","date":"2018-05-10T12:54:10.000Z","updated":"2018-05-10T12:55:14.000Z","comments":true,"path":"tags/index.html","permalink":"http://yoursite.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"Git+Iterm","slug":"Git+iterm","date":"2020-06-30T11:31:17.000Z","updated":"2020-07-01T01:16:57.755Z","comments":true,"path":"2020/06/30/Git+iterm/","link":"","permalink":"http://yoursite.com/2020/06/30/Git+iterm/","excerpt":"","text":"###Iterm:iTerm2设置及使用 ###Git: Sumery:1、撤销修改场景1：当你改乱了工作区某个文件的内容，想直接丢弃工作区的修改时，用命令git checkout file场景2：当你不但改乱了工作区某个文件的内容，还添加到了暂存区时，想丢弃修改，分两步，第一&gt;步用命令git reset HEAD file，就回到了场景1，第二步按场景1操作。（git reset命令既可以回退版本，也可以把暂存区的修改回退到工作区。当我们用HEAD时，表示最&gt;新的版本。）2、 soft hard mixed区别 1、初始化git init //创建git clone /path/to/repository //检出git config –global user.email “you@example.com“ //配置emailgit config –global user.name “Name” //配置用户名git remote add origin url 2、操作git add // 文件添加，A → Bgit add . // 所有文件添加，A → Bgit commit -m “代码提交信息” //文件提交，B → Cgit commit –amend //与上次commit合并, *B → Cgit push origin master //推送至master分支, C → Dgit pull //更新本地仓库至最新改动， D → Agit fetch //抓取远程仓库更新， D → Cgit log //查看提交记录git status //查看修改状态git diff//查看详细修改内容git show//显示某次提交的内容 3、撤销操作git reset //某个文件索引会回滚到最后一次提交， C → Bgit reset//索引会回滚到最后一次提交， C → Bgit reset –hard // 索引会回滚到最后一次提交， C → B → Agit checkout // 从index复制到workspace， B → Agit checkout – files // 文件从index复制到workspace， B → Agit checkout HEAD – files // 文件从local repository复制到workspace， C → A 4、分支git checkout -b branch_name //创建名叫“branch_name”的分支，并切换过去git checkout master //切换回主分支git branch -d branch_name // 删除名叫“branch_name”的分支git push origin branch_name //推送分支到远端仓库git merge branch_name // 合并分支branch_name到当前分支(如master)git rebase //衍合，线性化的自动， D → A 5、冲突处理git diff //对比workspace与indexgit diff HEAD //对于workspace与最后一次commitgit diff &lt;source_branch&gt; &lt;target_branch&gt; //对比差异git add //修改完冲突，需要add以标记合并成功 Sumery:1、撤销修改场景1：当你改乱了工作区某个文件的内容，想直接丢弃工作区的修改时，用命令git checkout file场景2：当你不但改乱了工作区某个文件的内容，还添加到了暂存区时，想丢弃修改，分两步，第一步用命令git reset HEAD file，就回到了场景1，第二步按场景1操作。（git reset命令既可以回退版本，也可以把暂存区的修改回退到工作区。当我们用HEAD时，表示最新的版本。）2、 soft hard mixed区别","categories":[],"tags":[{"name":"工具箱","slug":"工具箱","permalink":"http://yoursite.com/tags/工具箱/"}]},{"title":"vscode","slug":"vscode","date":"2020-06-30T02:43:29.000Z","updated":"2020-06-30T11:24:30.845Z","comments":true,"path":"2020/06/30/vscode/","link":"","permalink":"http://yoursite.com/2020/06/30/vscode/","excerpt":"","text":"1、自定义键盘快捷键：文件-&gt;首选项-&gt;键盘快捷方式 常见的快捷键","categories":[],"tags":[{"name":"工具箱","slug":"工具箱","permalink":"http://yoursite.com/tags/工具箱/"}]},{"title":"字符串的排列","slug":"字符串的排列","date":"2019-08-23T07:25:02.000Z","updated":"2019-08-23T07:28:12.000Z","comments":true,"path":"2019/08/23/字符串的排列/","link":"","permalink":"http://yoursite.com/2019/08/23/字符串的排列/","excerpt":"","text":"给定两个字符串 s1 和 s2，写一个函数来判断 s2 是否包含 s1 的排列。换句话说，第一个字符串的排列之一是第二个字符串的子串。示例1:输入: s1 = “ab” s2 = “eidbaooo”输出: True解释: s2 包含 s1 的排列之一 (“ba”).示例2:输入: s1= “ab” s2 = “eidboaoo”输出: False 经典滑动窗口：1234567891011121314151617181920212223class Solution &#123;public: bool checkInclusion(string s1, string s2) &#123; if (s1.size() &gt; s2.size()) &#123; return false; &#125; int windowsize = s1.size(); vector&lt;int&gt; hashmap1(26, 0); vector&lt;int&gt; hashmap2(26, 0); for (int i = 0; i &lt; windowsize; i++) &#123; hashmap1[s1[i] - 'a']++; hashmap2[s2[i] - 'a']++; &#125; for (int i = windowsize; i &lt; s2.size(); i++) &#123; if (hashmap1 == hashmap2) &#123; return 1; &#125; hashmap2[s2[i - windowsize] - 'a']--; //窗口右移 hashmap2[s2[i] - 'a']++; &#125; return hashmap1 == hashmap2; &#125;&#125;;","categories":[],"tags":[{"name":"算法","slug":"算法","permalink":"http://yoursite.com/tags/算法/"}]},{"title":"最长回文字串","slug":"最长回文字串","date":"2019-08-21T06:18:54.000Z","updated":"2019-08-21T06:19:28.000Z","comments":true,"path":"2019/08/21/最长回文字串/","link":"","permalink":"http://yoursite.com/2019/08/21/最长回文字串/","excerpt":"","text":"给定一个字符串 s，找到 s 中最长的回文子串。你可以假设 s 的最大长度为 1000。示例 1：输入: “babad”输出: “bab”注意: “aba” 也是一个有效答案。示例 2：输入: “cbbd”输出: “bb” 1234567891011121314151617181920212223242526class Solution &#123;public: int getNum(string s, int i, int j) &#123; while (i &gt;= 0 &amp;&amp; j &lt; s.size() &amp;&amp; s[i] == s[j]) &#123; i--; j++; &#125; return j - i - 1; &#125; string longestPalindrome(string s) &#123; if (s.size() == 0) return s; int st = 0, e = 0; for (int i = 0; i &lt; s.size() - 1; i++) &#123; int len1 = getNum(s, i, i); int len2 = getNum(s, i, i+1); int len = max(len1, len2); if (len &gt; e - st) &#123; st = i - (len - 1) / 2; e = i + len / 2; &#125; &#125; return s.substr(st, e - st + 1); &#125; &#125;;","categories":[],"tags":[{"name":"算法","slug":"算法","permalink":"http://yoursite.com/tags/算法/"}]},{"title":"实现trie","slug":"实现trie","date":"2019-08-18T14:02:22.000Z","updated":"2019-08-18T16:17:12.000Z","comments":true,"path":"2019/08/18/实现trie/","link":"","permalink":"http://yoursite.com/2019/08/18/实现trie/","excerpt":"","text":"应用场景12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455class Trie &#123;public: /** Initialize your data structure here. */ Trie* next[26] = &#123;NULL&#125;; bool isLeaf; Trie() &#123; isLeaf = false; &#125; /** Inserts a word into the trie. */ void insert(string word) &#123; Trie* node = this; for (char c : word) &#123; int i = int(c - 'a'); if (node-&gt;next[i] == NULL) &#123; node-&gt;next[i] = new Trie(); &#125; node = node-&gt;next[i]; &#125; node-&gt;isLeaf = true; return; &#125; /** Returns if the word is in the trie. */ bool search(string word) &#123; Trie* node = this; for (char c : word) &#123; int i = int(c - 'a'); if (node-&gt;next[i]) &#123; node = node-&gt;next[i]; &#125; else &#123; return 0; &#125; &#125; if (node-&gt;isLeaf) &#123; return 1; &#125; return 0; &#125; /** Returns if there is any word in the trie that starts with the given prefix. */ bool startsWith(string prefix) &#123; Trie* node = this; for (char c : prefix) &#123; int i = int(c - 'a'); if (node-&gt;next[i]) &#123; node = node-&gt;next[i]; &#125; else &#123; return 0; &#125; &#125; return 1; &#125; &#125;;","categories":[],"tags":[{"name":"算法","slug":"算法","permalink":"http://yoursite.com/tags/算法/"}]},{"title":"双指针例题1","slug":"双指针例题1","date":"2019-08-17T10:16:27.000Z","updated":"2019-08-17T10:17:36.000Z","comments":true,"path":"2019/08/17/双指针例题1/","link":"","permalink":"http://yoursite.com/2019/08/17/双指针例题1/","excerpt":"","text":"一个有符号的有序数组,问这些数平方之后有多少个不重复的数?12345678910111213141516171819202122232425262728293031#include&lt;bits/stdc++.h&gt;using namespace std;int func(vector&lt;int&gt; a) &#123; int num = 1; int pre = abs(a[0]); int n = a.size(); int i = 0, j = n-1; while (i &lt; j) &#123; if (a[i] &gt; a[j]) &#123; if (pre != abs(a[i])) &#123; pre = abs(a[i]); num++; &#125; i++; &#125; else &#123; if (pre != abs(a[j])) &#123; pre = abs(a[j]); num++; &#125; j--; &#125; &#125; return num;&#125;int main()&#123; int v[] = &#123;-5,-3,-1,1,1,2&#125;; vector&lt;int&gt; a (v, v + 6); int num = func(a); cout&lt;&lt;num&lt;&lt;endl;&#125;","categories":[],"tags":[{"name":"算法","slug":"算法","permalink":"http://yoursite.com/tags/算法/"}]},{"title":"最长上升子序列","slug":"最长上升子序列","date":"2019-08-11T06:09:26.000Z","updated":"2019-08-11T06:14:10.000Z","comments":true,"path":"2019/08/11/最长上升子序列/","link":"","permalink":"http://yoursite.com/2019/08/11/最长上升子序列/","excerpt":"","text":"两种方法：1.dp 时间复杂度O（n^2）2.贪心 + 二分 时间复杂度 O(n*log(n)) 1.dp1234567891011121314151617181920class Solution &#123;public: int lengthOfLIS(vector&lt;int&gt;&amp; nums) &#123; if (nums.size() == 0) return 0; vector&lt;int&gt; b; b.push_back(1); int maxx = 1; for (int i = 1; i &lt; nums.size(); i++) &#123; int m = 0; for (int j = 0; j &lt; i; j++) &#123; if (nums[j] &lt; nums[i] &amp;&amp; b[j] &gt; m) &#123; m = b[j]; &#125; &#125; b.push_back(m+1); maxx = max(b[i], maxx); &#125; return maxx; &#125;&#125;; 2.贪心 + 二分a[i]表示第i个数据。dp[i]表示表示长度为i+1的LIS结尾元素的最小值。利用贪心的思想，对于一个上升子序列，显然当前最后一个元素越小，越有利于添加新的元素，这样LIS长度自然更长。因此，我们只需要维护dp数组，其表示的就是长度为i+1的LIS结尾元素的最小值，保证每一位都是最小值， 这样子dp数组的长度就是LIS的长度。 dp数组具体维护过程同样举例讲解更为清晰。同样对于序列 a(1, 7, 3, 5, 9, 4, 8)，dp的变化过程如下： dp[0] = a[0] = 1，长度为1的LIS结尾元素的最小值自然没得挑，就是第一个数。 （dp = {1}）对于a[1]=7，a[1]&gt;dp[0]，因此直接添加到dp尾，dp[1]=a[1]。（dp = {1, 7}）对于a[2]=3，dp[0]&lt; a[2]&lt; dp[1]，因此a[2]替换dp[1]，令dp[1]=a[2]，因为长度为2的LIS，结尾元素自然是3好过于7，因为越小这样有利于后续添加新元素。 （dp = {1, 3}）对于a[3]=5，a[3]&gt;dp[1]，因此直接添加到dp尾，dp[2]=a[3]。 （dp = {1, 3, 5}）对于a[4]=9，a[4]&gt;dp[2]，因此同样直接添加到dp尾，dp[3]=a[9]。 （dp = {1, 3, 5, 9}）对于a[5]=4，dp[1]&lt; a[5]&lt; dp[2]，因此a[5]替换值为5的dp[2]，因此长度为3的LIS，结尾元素为4会比5好，越小越好嘛。（dp = {1, 3, 4, 9}）对于a[6]=8，dp[2]&lt; a[6]&lt; dp[3]，同理a[6]替换值为9的dp[3]，道理你懂。 （dp = {1, 3, 5, 8}）这样子dp数组就维护完毕，所求LIS长度就是dp数组长度4。通过上述求解，可以发现dp数组是单调递增的，因此对于每一个a[i]，先判断是否可以直接插入到dp数组尾部， 即比较其与dp数组的最大值即最后一位；如果不可以，则找出dp中第一个大于等于a[i]的位置，用a[i]替换之。这个过程可以利用二分查找，因此查找时间复杂度为O(logN)，所以总的时间复杂度为O(N*logN)1234567891011121314151617181920212223242526272829303132333435363738class Solution &#123;public: int binary(vector&lt;int&gt; v, int x) &#123; int i = 0, j = v.size() - 1; while (i &lt; j) &#123; int mid = i + (j - i) / 2; if (v[mid] &gt;= x) &#123; j = mid; &#125; else &#123; i = mid + 1; &#125; &#125; return i; &#125; int lengthOfLIS(vector&lt;int&gt;&amp; nums) &#123; int n = nums.size(); if (n == 0) &#123; return 0; &#125; int len = 0; vector&lt;int&gt; dp; dp.push_back(nums[0]); for (int i = 1; i &lt; n; i++) &#123; if (nums[i] &gt; dp[len]) &#123; dp.push_back(nums[i]); len++; &#125; else &#123; int id = binary(dp, nums[i]); dp[id] = nums[i]; &#125; &#125; return len + 1; &#125;&#125;;","categories":[],"tags":[{"name":"算法","slug":"算法","permalink":"http://yoursite.com/tags/算法/"}]},{"title":"最大 BST 子树","slug":"最大-BST-子树","date":"2019-08-10T05:41:10.000Z","updated":"2019-08-10T05:44:36.000Z","comments":true,"path":"2019/08/10/最大-BST-子树/","link":"","permalink":"http://yoursite.com/2019/08/10/最大-BST-子树/","excerpt":"","text":"给定一个二叉树，找到其中最大的二叉搜索树（BST）子树，其中最大指的是子树节点数最多的。输入: [10,5,15,1,8,null,7] 10 / \\ 5 15 / \\ \\1 8 7其中最大的BTS子树是 5 1 8 1.判断是不是BTS： 12345678910bool bst(TreeNode* root) &#123; return pd(root, INT_MIN, INT_MAX);&#125;bool pd(TreeNode*root, int low, int high) &#123; if (root == NULL) return 1; if (root-&gt;val &gt; low &amp;&amp; root-&gt;val &lt;high) &#123; return pd (root-&gt;left, low, root-&gt;val) &amp;&amp; pd(root-&gt;right, root-&gt;val, high); &#125; return 0;&#125; 2.统计某个树的结点数量：123456int num(TreeNode* root) &#123; if (root == NULL) return 0; int left = num(root-&gt;left); int right = num(root-&gt;right); return left + right + 1;&#125; 3.实现：123456789101112int largestBSTSubtree(TreeNode* root) &#123; if (root == NULL) &#123; return 0; &#125; if (bst(root)) &#123; return num(root); &#125; int left = largestBSTSubtree(root-&gt;left); int right = largestBSTSubtree(root-&gt;right); return max(left, right); &#125;","categories":[],"tags":[{"name":"算法","slug":"算法","permalink":"http://yoursite.com/tags/算法/"}]},{"title":"无重复字符的最长子串","slug":"无重复字符的最长子串","date":"2019-08-07T13:33:13.000Z","updated":"2019-08-07T13:44:38.000Z","comments":true,"path":"2019/08/07/无重复字符的最长子串/","link":"","permalink":"http://yoursite.com/2019/08/07/无重复字符的最长子串/","excerpt":"","text":"给定一个字符串，请你找出其中不含有重复字符的 最长子串 的长度。简单分析：假设给出一个字符串： abcdechjil第一个重复字符是c, 然而如果是简单暴力的话， 第一次从a开始找，找到第一个重复字符c，break，然后下一次要从b开始找但是发现一个问题，因为b在 c的左边， 所以无论怎么样 无重复字符最长字串长度 都不会大于 从a开始遍历的长度。所以，下一次直接从重复字符c的下一个字符d开始遍历就ok。12345//暴力伪代码for (int i = 0; i &lt; n； i++)&#123; for (int j = i + 1; j &lt; n; j++) &#125; 1.没用队列12345678910111213141516171819202122232425class Solution &#123;public: int lengthOfLongestSubstring(string s) &#123; if (s.size() == 1) return 1; map&lt;char,int&gt; m; int n = s.size(); int maxx = 0; int j = 0; for (int i = 0; i &lt; n; i++) &#123; if (m.find(s[i]) != m.end()) &#123; //找到了 int id = m[s[i]]; for (int z = j; z &lt; id; z++) &#123; m.erase(s[z]); &#125; maxx = max(maxx, i - j); j = id + 1; // flag = 1; &#125; else &#123; maxx = max(maxx, i - j + 1); &#125; m[s[i]] = i; &#125; return maxx; &#125;&#125;; 2.用队列1234567891011121314151617181920212223242526class Solution &#123;public: int lengthOfLongestSubstring(string s) &#123; queue&lt;int&gt; q; map&lt;char, int&gt; m; int maxx = 0; for (int i = 0; i &lt; s.size(); i++) &#123; if (m.find(s[i]) == m.end()) &#123; q.push(s[i]); m[s[i]] = 1; int size = q.size(); maxx = max(maxx, size); &#125; else &#123; while (!q.empty() &amp;&amp; q.front() != s[i]) &#123; char c = q.front(); q.pop(); m.erase(c); &#125; q.pop(); q.push(s[i]); &#125; &#125; return maxx; &#125;&#125;;","categories":[],"tags":[{"name":"算法","slug":"算法","permalink":"http://yoursite.com/tags/算法/"}]},{"title":"递增顺序查找树","slug":"递增顺序查找树","date":"2019-08-04T07:21:32.000Z","updated":"2019-08-04T10:17:34.000Z","comments":true,"path":"2019/08/04/递增顺序查找树/","link":"","permalink":"http://yoursite.com/2019/08/04/递增顺序查找树/","excerpt":"","text":"给定一个树，按中序遍历重新排列树，使树中最左边的结点现在是树的根，并且每个结点没有左子结点，只有一个右子结点。示例 ： 输入：[5,3,6,2,4,null,8,1,null,null,null,7,9] 5 / \\ 3 6 / \\ \\ 2 4 8 / / \\1 7 9 输出：[1,null,2,null,3,null,4,null,5,null,6,null,7,null,8,null,9] 1 \\ 2 \\ 3 \\ 4 \\ 5 \\ 6 \\ 7 \\ 8 \\ 9 123456789101112131415161718192021222324252627282930/** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: TreeNode* increasingBST(TreeNode* root) &#123; if (root == NULL) return root; root-&gt;right = increasingBST(root-&gt;right); if (root-&gt;left) &#123; TreeNode* left = root-&gt;left; root-&gt;left = NULL; TreeNode* node = left; while (node-&gt;right) &#123; node = node-&gt;right; &#125; node-&gt;right = root; return increasingBST(left); &#125; return root; &#125;&#125;;","categories":[],"tags":[{"name":"算法","slug":"算法","permalink":"http://yoursite.com/tags/算法/"}]},{"title":"设计容器","slug":"设计容器","date":"2019-08-04T06:44:08.000Z","updated":"2019-08-04T06:44:42.000Z","comments":true,"path":"2019/08/04/设计容器/","link":"","permalink":"http://yoursite.com/2019/08/04/设计容器/","excerpt":"","text":"设计一个支持在平均 时间复杂度 O(1) 下，执行以下操作的数据结构。insert(val)：当元素 val 不存在时，向集合中插入该项。remove(val)：元素 val 存在时，从集合中移除该项。getRandom：随机返回现有集合中的一项。每个元素应该有相同的概率被返回。 12345678910111213141516171819202122232425262728293031class RandomizedSet &#123;public: vector&lt;int&gt; v; map&lt;int, int&gt; m; bool insert(int val) &#123; if (m.find(val) != m.end()) &#123; return false; &#125; v.push_back(val); m[val] = v.size() - 1; return true; &#125; bool remove(int val) &#123; if (m.find(val) == m.end()) &#123; return false; &#125; else &#123; int i = m[val]; // int last = v[v.size()-1]; m.erase(val); v[i] = last; v.pop_back(); if (v.size() != i) // m[last] = i; &#125; return true; &#125; int getRandom() &#123; int n = v.size(); return v[rand()%n]; &#125;&#125;;","categories":[],"tags":[{"name":"算法","slug":"算法","permalink":"http://yoursite.com/tags/算法/"}]},{"title":"二分查找第一个比K大的数","slug":"二分查找第一个比K大的数","date":"2019-08-04T06:05:30.000Z","updated":"2019-08-11T06:08:42.000Z","comments":true,"path":"2019/08/04/二分查找第一个比K大的数/","link":"","permalink":"http://yoursite.com/2019/08/04/二分查找第一个比K大的数/","excerpt":"","text":"1.123456789101112131415int find(vector&lt;int&gt; a, int k) &#123; int l = 0, r = a.size(); int id; while (l &lt;= r) &#123; int mid = l + (r - l) / 2; if (a[mid] &gt; k) &#123; id = mid; r = mid - 1; &#125; else &#123; l = mid + 1; &#125; &#125; return id;&#125; 2. 1234567891011121314int binary(vector&lt;int&gt; v, int x) &#123; int i = 0, j = v.size() - 1; while (i &lt; j) &#123; int mid = i + (j - i) / 2; if (v[mid] &gt;= x) &#123; j = mid; &#125; else &#123; i = mid + 1; &#125; &#125; return i;&#125;","categories":[],"tags":[{"name":"算法","slug":"算法","permalink":"http://yoursite.com/tags/算法/"}]},{"title":"虚拟内存","slug":"虚拟内存","date":"2019-07-28T10:22:25.000Z","updated":"2019-07-28T10:25:20.000Z","comments":true,"path":"2019/07/28/虚拟内存/","link":"","permalink":"http://yoursite.com/2019/07/28/虚拟内存/","excerpt":"","text":"功能：一：进程内存管理它有助于进程进行内存管理，主要体现在：1.内存完整性：由于虚拟内存对进程的”欺骗”，每个进程都认为自己获取的内存是一块连续的地址。我们在编写应用程序时，就不用考虑大块地址的分配，总是认为系统有足够的大块内存即可。2.安全：由于进程访问内存时，都要通过页表来寻址，操作系统在页表的各个项目上添加各种访问权限标识位，就可以实现内存的权限控制。二：数据共享通过虚拟内存更容易实现内存和数据的共享。在进程加载系统库时，总是先分配一块内存，将磁盘中的库文件加载到这块内存中，在直接使用物理内存时，由于物理内存地址唯一，即使系统发现同一个库在系统内加载了两次，但每个进程指定的加载内存不一样，系统也无能为力。而在使用虚拟内存时，系统只需要将进程的虚拟内存地址指向库文件所在的物理内存地址即可。如上文图中所示，进程 P1 和 P2 的 B 地址都指向了物理地址 C。而通过使用虚拟内存使用共享内存也很简单，系统只需要将各个进程的虚拟内存地址指向系统分配的共享内存地址即可。三：SWAP虚拟内存可以让帮进程”扩充”内存。我们前文提到了虚拟内存通过缺页中断为进程分配物理内存，内存总是有限的，如果所有的物理内存都被占用了怎么办呢？Linux 提出 SWAP 的概念，Linux 中可以使用 SWAP 分区，在分配物理内存，但可用内存不足时，将暂时不用的内存数据先放到磁盘上，让有需要的进程先使用，等进程再需要使用这些数据时，再将这些数据加载到内存中，通过这种”交换”技术，Linux 可以让进程使用更多的内存。","categories":[],"tags":[{"name":"操作系统","slug":"操作系统","permalink":"http://yoursite.com/tags/操作系统/"}]},{"title":"二叉搜索树中序后继","slug":"二叉搜索树中序后继","date":"2019-07-26T03:39:09.000Z","updated":"2019-07-26T03:39:40.000Z","comments":true,"path":"2019/07/26/二叉搜索树中序后继/","link":"","permalink":"http://yoursite.com/2019/07/26/二叉搜索树中序后继/","excerpt":"","text":"给定一个结点，找出这个结点的后继结点中序遍历：左 中 右情况分类：一：结点的右子树不为空返回右子树的最左结点二：结点的右子树为空1.如果这个结点是根结点，直接返回NULL2.如果这个结点是父节点的左儿子，直接返回父亲结点3.如果这个结点是父节点的右儿子，不断向上找第一个结点，这个结点是他父亲结点的左儿子 123456789101112131415161718192021222324252627282930313233343536// Definition for a Node./*class Node &#123;public: int val; Node* left; Node* right; Node* parent;&#125;;*/class Solution &#123;public: Node* inorderSuccessor(Node* node) &#123; if (node-&gt;right) &#123; Node* p = node-&gt;right; while (p-&gt;left) &#123; p = p-&gt;left; &#125; return p; &#125; else &#123; if (node-&gt;parent == NULL) return NULL; if (node-&gt;parent-&gt;left == node) return node-&gt;parent; else &#123; Node *p = node-&gt;parent; while (p &amp;&amp; p-&gt;right == node) &#123; node = p; p = p-&gt;parent; &#125; return p; &#125; &#125; &#125;&#125;;","categories":[],"tags":[{"name":"算法","slug":"算法","permalink":"http://yoursite.com/tags/算法/"}]},{"title":"二叉树的最近公共祖先","slug":"二叉树的最近公共祖先","date":"2019-07-26T02:31:07.000Z","updated":"2019-07-26T02:31:28.000Z","comments":true,"path":"2019/07/26/二叉树的最近公共祖先/","link":"","permalink":"http://yoursite.com/2019/07/26/二叉树的最近公共祖先/","excerpt":"","text":"1234567891011121314151617181920212223242526272829303132/** * Definition for a binary tree node. * struct c &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: TreeNode* result; bool isInside(TreeNode* root, TreeNode* p, TreeNode* q) &#123; if (root == NULL) &#123; return 0; &#125; bool left, right; left = isInside(root-&gt;left, p, q); right = isInside(root-&gt;right, p, q); if ((right &amp;&amp; left) || ((root == p || root == q) &amp;&amp; (left || right))) &#123; result = root; return 0; &#125; if (left || right || root == p || root == q) return 1; return 0; &#125; TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) &#123; isInside(root, p, q); return result; &#125;&#125;;","categories":[],"tags":[{"name":"算法","slug":"算法","permalink":"http://yoursite.com/tags/算法/"}]},{"title":"一个进栈的所有出栈序列","slug":"一个进栈的所有出栈序列","date":"2019-07-26T01:53:17.000Z","updated":"2019-07-26T02:03:12.000Z","comments":true,"path":"2019/07/26/一个进栈的所有出栈序列/","link":"","permalink":"http://yoursite.com/2019/07/26/一个进栈的所有出栈序列/","excerpt":"","text":"1234567891011121314151617181920212223242526272829303132333435//给出出栈顺序 求所有进栈的序列 || 给出入栈顺序 求出栈顺序 void print(stack&lt;int&gt; v) &#123; while (v.size() != 0) &#123; cout&lt;&lt;v.top()&lt;&lt;\" \"; v.pop(); &#125; cout&lt;&lt;endl;&#125;//a存放入栈序列，b模拟入栈， c存放可能的出栈的序列void dfs(stack&lt;int&gt; a, stack&lt;int&gt; b, stack&lt;int&gt; c) &#123; if (a.size() == 0 &amp;&amp; b.size() == 0 ) &#123; print(c); return; &#125; if (a.size() != 0) &#123; //入栈 int val = a.top(); b.push(val); a.pop(); dfs(a, b, c); b.pop(); a.push(val); &#125; if (b.size() != 0) &#123; //出栈 int val = b.top(); c.push(val); b.pop(); dfs(a, b, c); c.pop(); b.push(val); &#125; return;&#125;","categories":[],"tags":[{"name":"算法","slug":"算法","permalink":"http://yoursite.com/tags/算法/"}]},{"title":"二叉树展开成链表","slug":"二叉树展开成链表","date":"2019-07-26T01:49:36.000Z","updated":"2019-07-26T03:44:34.000Z","comments":true,"path":"2019/07/26/二叉树展开成链表/","link":"","permalink":"http://yoursite.com/2019/07/26/二叉树展开成链表/","excerpt":"","text":"给定一个二叉树，原地将它展开为链表。例如，给定二叉树 1 / \\ 2 5 / \\ \\3 4 6展开为：1-2-3-4-5-6 123456789101112131415161718192021/** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: TreeNode* last; void flatten(TreeNode* root) &#123; if (root == NULL) return; flatten(root-&gt;right); flatten(root-&gt;left); root-&gt;right = last; root-&gt;left = NULL; last = root; &#125;&#125;; 链接：https://leetcode-cn.com/problems/flatten-binary-tree-to-linked-list","categories":[],"tags":[{"name":"算法","slug":"算法","permalink":"http://yoursite.com/tags/算法/"}]},{"title":"环形链表","slug":"环形链表","date":"2019-07-26T01:29:52.000Z","updated":"2019-07-26T04:44:16.000Z","comments":true,"path":"2019/07/26/环形链表/","link":"","permalink":"http://yoursite.com/2019/07/26/环形链表/","excerpt":"","text":"一个含有循环链表的链表怎么求它开始循环的入口？给出一个循环链表的例子：1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;3 最后5又指向了3，也就是说3-&gt;4-&gt;5-&gt;3形成了一个环假设非环形的长度是x, 环形的长度是y, 链表总长度是n = x + y思路：两个指针， fast一次走两步， slow一次走一步， 总有一次他们会在环的某一个位置相遇。于是可以列出关系表达式：fast = 2slow (一个走一步，一个走两步，走了相同的时间)fast = slow + ny (fast比slow多走了n圈的环)2slow = slow + ny -&gt; slow = ny得出了关键的表达式： slow = ny, 假设一下slow处于环形起点的时候，n*y 圈之后还会回到起点。但是，slow是从链表的起点开始的，所以从入口要回退x步， 就是fast和slow相遇的点， 也就是说 非环形的链表长度x 等于 fast和slow最后相遇的节点到环形入口的长度。 123456789101112131415161718192021222324class Solution &#123;public: ListNode *detectCycle(ListNode *head) &#123; ListNode* fast = head; ListNode* slow = head; while (fast != NULL &amp;&amp; fast-&gt;next != NULL) &#123; fast = fast-&gt;next-&gt;next; slow = slow-&gt;next; if (fast == slow) &#123; break; &#125; &#125; if (fast == NULL || fast-&gt;next == NULL) return NULL; fast = head; while(fast != slow) &#123; fast = fast-&gt;next; slow = slow-&gt;next; &#125; return fast; &#125;&#125;;","categories":[],"tags":[{"name":"算法","slug":"算法","permalink":"http://yoursite.com/tags/算法/"}]},{"title":"删除链表重复元素","slug":"删除链表重复元素","date":"2019-07-26T01:29:25.000Z","updated":"2019-08-04T06:03:08.000Z","comments":true,"path":"2019/07/26/删除链表重复元素/","link":"","permalink":"http://yoursite.com/2019/07/26/删除链表重复元素/","excerpt":"","text":"输入: 1-&gt;2-&gt;3-&gt;3-&gt;4-&gt;4-&gt;5输出: 1-&gt;2-&gt;5 1234567891011121314151617181920212223242526272829class Solution &#123;public: ListNode* deleteDuplicates(ListNode* head) &#123; ListNode* h = NULL; ListNode* pre = NULL; ListNode* cur = head; ListNode* r = NULL; while (cur != NULL) &#123; if (juge(pre, cur) &amp;&amp; juge(cur, cur-&gt;next)) &#123; if (h == NULL) &#123; h = new ListNode(cur-&gt;val); r = h; &#125; else &#123; r-&gt;next = new ListNode(cur-&gt;val); r = r-&gt;next; &#125; &#125; pre = cur; cur = cur-&gt;next; &#125; return h; &#125; bool juge(ListNode* node1, ListNode* node2) &#123; if (node1 == NULL || node2 == NULL || node1-&gt;val != node2-&gt;val) &#123; return true; &#125; return false; &#125;&#125;;","categories":[],"tags":[{"name":"算法","slug":"算法","permalink":"http://yoursite.com/tags/算法/"}]},{"title":"k个一组翻转链表","slug":"k个一组翻转链表","date":"2019-07-26T01:27:27.000Z","updated":"2019-07-26T01:28:22.000Z","comments":true,"path":"2019/07/26/k个一组翻转链表/","link":"","permalink":"http://yoursite.com/2019/07/26/k个一组翻转链表/","excerpt":"","text":"给你一个链表，每 k 个节点一组进行翻转，请你返回翻转后的链表。k 是一个正整数，它的值小于或等于链表的长度。如果节点总数不是 k 的整数倍，那么请将最后剩余的节点保持原有顺序。 123456789101112131415161718192021222324252627282930313233343536373839class Solution &#123;public: ListNode* reverse(ListNode* root) &#123; ListNode* pre = NULL; ListNode* node = root; ListNode* next; while (node != NULL) &#123; next = node-&gt;next; node-&gt;next = pre; pre = node; node = next; &#125; return pre; &#125; ListNode* reverseKGroup(ListNode* head, int k) &#123; if (head == NULL || head-&gt;next == NULL || k == 1) return head; ListNode* result = new ListNode(-1); ListNode* r = result; while (head != NULL) &#123; int i; ListNode* start = head; ListNode* next; for (i = 1; i &lt; k &amp;&amp; head != NULL; i++) head = head-&gt;next; if (i &lt;= k &amp;&amp; head == NULL) &#123; r-&gt;next = start; break; &#125; else &#123; next = head-&gt;next; head-&gt;next = NULL; r-&gt;next = reverse(start); r = start; head = next; &#125; &#125; return result-&gt;next; &#125;&#125;;","categories":[],"tags":[{"name":"算法","slug":"算法","permalink":"http://yoursite.com/tags/算法/"}]},{"title":"LRU","slug":"LRU","date":"2019-07-25T08:12:45.000Z","updated":"2019-08-04T05:56:56.000Z","comments":true,"path":"2019/07/25/LRU/","link":"","permalink":"http://yoursite.com/2019/07/25/LRU/","excerpt":"","text":"123456789101112131415161718192021222324252627282930313233343536373839class LRUCache &#123;public: list&lt;int&gt; link; map&lt;int, int&gt; m; int capacity; LRUCache(int capacity) &#123; this-&gt;capacity = capacity; &#125; int get(int key) &#123; if(m.find(key) == m.end()) &#123; return -1; &#125; else &#123; link.remove(key); link.push_front(key); &#125; return m[key]; &#125; void put(int key, int value) &#123; if (m.find(key) != m.end()) &#123; //已存在 m[key] = value; link.remove(key); link.push_front(key); &#125; else &#123; //不存在 if (m.size() &gt;= capacity) &#123; int keyLast = link.back(); link.pop_back(); m.erase(keyLast); link.push_front(key); m[key] = value; &#125; else &#123; m[key] = value; link.push_front(key); &#125; &#125; &#125;&#125;;","categories":[],"tags":[{"name":"算法","slug":"算法","permalink":"http://yoursite.com/tags/算法/"}]},{"title":"快速排序三数取中","slug":"快速排序三数取中","date":"2019-07-25T08:01:11.000Z","updated":"2019-07-28T03:17:46.000Z","comments":true,"path":"2019/07/25/快速排序三数取中/","link":"","permalink":"http://yoursite.com/2019/07/25/快速排序三数取中/","excerpt":"","text":"给一个有序的数组，那代码的时间复杂度就是O(n^2)拉。最好就是取一个要排序数组中所有值的中值，（很难）1234567891011121314151617181920212223242526272829303132333435363738class Solution &#123;public: int partition(vector&lt;int&gt;&amp; nums, int left, int right) &#123; int mid = (left + right) / 2; if (nums[left] &gt; nums[right]) swap(nums[left], nums[right]); if (nums[mid] &gt; nums[right]) swap(nums[mid], nums[right]); if (nums[mid] &gt; nums[left]) swap(nums[mid], nums[left]); //把中值换到最左边 int val = nums[left]; int i = left, j = right; //填坑法 while (i &lt; j) &#123; while (i &lt; j &amp;&amp; nums[j] &gt;= val) j--; nums[i] = nums[j]; while (i &lt; j &amp;&amp; nums[i] &lt;= val) i++; nums[j] = nums[i]; &#125; nums[i] = val; return i; &#125; void sort(vector&lt;int&gt;&amp; nums, int left, int right) &#123; if (left &gt;= right) return; int mid = partition(nums, left, right); sort(nums, left, mid-1); sort(nums, mid + 1, right); &#125; vector&lt;int&gt; sortArray(vector&lt;int&gt;&amp; nums) &#123; sort(nums, 0, nums.size()-1); return nums; &#125;&#125;; 没有优化的快排贴一下：1234567891011121314151617181920212223242526int pattern(int l,int r)&#123; int i = l,j = r; while(i&lt;j) &#123; while(i&lt;j &amp;&amp; a[i]&lt;=a[j]) j--; if(i&lt;j) swap(a[i],a[j]); while(i&lt;j &amp;&amp; a[i]&lt;=a[j]) i++; if(i&lt;j) swap(a[i],a[j]); &#125; return i;&#125;void sort(int i,int j)&#123; if(i&lt;j) &#123; int mid = pattern(i,j); sort(i,mid-1); sort(mid+1,j); &#125;&#125;","categories":[],"tags":[{"name":"算法","slug":"算法","permalink":"http://yoursite.com/tags/算法/"}]},{"title":"冒泡优化","slug":"冒泡优化","date":"2019-07-17T10:12:20.000Z","updated":"2019-07-17T10:16:52.000Z","comments":true,"path":"2019/07/17/冒泡优化/","link":"","permalink":"http://yoursite.com/2019/07/17/冒泡优化/","excerpt":"","text":"优化1 没有进行过交换结束优化2 通过记录最后交换的位置，及终点的位置优化3 波浪排序+优化1+优化21234567891011121314151617181920212223242526272829303132333435363738394041#if 0#include&lt;bits/stdc++.h&gt; using namespace std; int a[10000];int n;void sort(int a[], int n) &#123; bool flag = 0; int k = n-1; int last; for (int i = 0; i &lt; n-1; i++) &#123; flag = 0; for (int j = 0; j &lt; k; j++) &#123; sum++; if (a[j] &gt; a[j+1]) &#123; flag = 1; last = j; swap(a[j], a[j+1]); &#125; &#125; if (flag == 0) &#123; break; &#125; k = last; &#125;&#125;int main()&#123; while(1) &#123; sum = 0; cin&gt;&gt;n; for (int i = 0; i &lt; n; i++) &#123; a[i] = rand() % n; &#125; sort(a, n); for(int i = 0; i &lt; n; i++) cout&lt;&lt;a[i]&lt;&lt;\" \"; &#125;&#125; #endif 12345678910111213141516171819202122232425262728293031323334353637383940414243444546#if 0 //波浪排序 就上两种优化#include&lt;bits/stdc++.h&gt;using namespace std;int a[100000],n;void sort(int a[], int n) &#123; int left = 0, right = n-1; int flag = 0; int last; while (left &lt; right) &#123; for (int i = left; i &lt; right; i++) &#123; sum++; if (a[i] &gt; a[i+1]) &#123; swap(a[i], a[i+1]); flag = 1; last = i; &#125; &#125; if (flag == 0) break; right = last; flag = 0; for (int j = last; j &gt; left; j--) &#123; sum++; if (a[j] &lt; a[j-1]) &#123; swap(a[j], a[j-1]); flag = 1; last = j; &#125; &#125; if (flag == 0) break; left = last; &#125;&#125;int main()&#123; while(1) &#123; cin&gt;&gt;n; for (int i = 0; i &lt; n; i++) &#123; a[i] = rand() % n; &#125; sort(a, n); for(int i = 0; i &lt; n; i++) cout&lt;&lt;a[i]&lt;&lt;\" \"; &#125;&#125; #endif","categories":[],"tags":[{"name":"算法","slug":"算法","permalink":"http://yoursite.com/tags/算法/"}]},{"title":"链表|排序","slug":"链表-排序","date":"2019-07-16T07:22:54.000Z","updated":"2019-07-18T06:25:14.000Z","comments":true,"path":"2019/07/16/链表-排序/","link":"","permalink":"http://yoursite.com/2019/07/16/链表-排序/","excerpt":"","text":"一：归并实现1.递归写法2.非递归写法，数组模拟递归（STL里源码思路）二:插入实现 归并递归写法：1234567891011121314151617181920212223242526272829303132333435class Solution &#123;public: ListNode* merge(ListNode* left, ListNode* right) &#123; ListNode* result = new ListNode(-1); ListNode* r = result; while (left != NULL &amp;&amp; right != NULL) &#123; if (left-&gt;val &lt;= right-&gt;val) &#123; r-&gt;next = left; r = r-&gt;next; left = left-&gt;next; &#125; else &#123; r-&gt;next = right; r = r-&gt;next; right = right-&gt;next; &#125; &#125; if (left != NULL) r-&gt;next = left; if (right != NULL) r-&gt;next = right; return result-&gt;next; &#125; ListNode* sortList(ListNode* head) &#123; if (head == NULL || head -&gt;next == NULL) return head; ListNode* pre = NULL; ListNode* fast = head, *slow = head; while (fast != NULL &amp;&amp; fast-&gt;next != NULL) &#123; pre = slow; fast = fast-&gt;next-&gt;next; slow = slow-&gt;next; &#125; pre-&gt;next = NULL; ListNode* left = sortList(head); ListNode* right = sortList(slow); return merge(left, right); &#125;&#125;; 归并非递归写法：第二种着实很难理解，模拟了很久。敬畏敬畏。大道至简，就是这样哇。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051class Solution &#123;public: ListNode* merge(ListNode* l1, ListNode* l2) &#123; ListNode* result = new ListNode(-1); ListNode* r = result; while (l1 &amp;&amp; l2) &#123; if (l1-&gt;val &lt;= l2-&gt;val) &#123; r-&gt;next = l1; r = r-&gt;next; l1 = l1-&gt;next; &#125; else &#123; r-&gt;next = l2; r = r-&gt;next; l2 = l2-&gt;next; &#125; &#125; if (l1) &#123; r-&gt;next = l1; &#125; if (l2) &#123; r-&gt;next = l2; &#125; return result-&gt;next; &#125; ListNode* table[64] = &#123;NULL&#125;; int fill = 0; int i = 0; ListNode* carry; ListNode* sortList(ListNode* head) &#123; if (head == NULL || head-&gt;next == NULL) return head; while (head != NULL) &#123; ListNode* next = head-&gt;next; head-&gt;next = carry; carry = head; i = 0; while (i &lt; fill &amp;&amp; table[i]) &#123; table[i] = merge(carry, table[i]); carry = NULL; swap(carry, table[i++]); &#125; swap(carry, table[i]); if(i == fill) fill++; head = next; &#125; ListNode* result; for (int i = 1; i &lt; fill; i++) &#123; table[i] = merge(table[i], table[i-1]); &#125; return table[fill-1]; &#125;&#125;; 插入排序：1234567891011121314151617181920class Solution &#123;public: ListNode* insertionSortList(ListNode* head) &#123; ListNode* result = new ListNode(INT_MIN); ListNode* r = result; ListNode* next; while (head != NULL) &#123; next = head-&gt;next; ListNode* r = result; while (r != NULL &amp;&amp; r-&gt;next != NULL &amp;&amp; r-&gt;next-&gt;val &lt; head-&gt;val) &#123; r = r-&gt;next; &#125; head-&gt;next = r-&gt;next; r-&gt;next = head; head = next; &#125; return result-&gt;next; &#125;&#125;;","categories":[],"tags":[{"name":"算法","slug":"算法","permalink":"http://yoursite.com/tags/算法/"}]},{"title":"进程","slug":"进程","date":"2019-07-06T13:24:39.000Z","updated":"2019-07-26T02:32:48.000Z","comments":true,"path":"2019/07/06/进程/","link":"","permalink":"http://yoursite.com/2019/07/06/进程/","excerpt":"","text":"一： 线程和进程各自有什么区别和优劣呢？ 进程是资源分配的最小单位，线程是程序执行的最小单位。 进程有自己的独立地址空间，每启动一个进程，系统就会为它分配地址空间，建立数据表来维护代码段、堆栈段和数据段，这种操作非常昂贵。而线程是共享进程中的数据的，使用相同的地 址空间，因此CPU切换一个线程的花费远比进程要小很多，同时创建一个线程的开销也比进程要小很多。 线程之间的通信更方便，同一进程下的线程共享全局变量、静态变量等数据，而进程之间的通信需要以通信的方式（IPC)进行。不过如何处理好同步与互斥是编写多线程程序的难点。 但是多进程程序更健壮，多线程程序只要有一个线程死掉，整个进程也死掉了，而一个进程死掉并不会对另外一个进程造成影响，因为进程有自己独立的地址空间。","categories":[],"tags":[{"name":"操作系统","slug":"操作系统","permalink":"http://yoursite.com/tags/操作系统/"}]},{"title":"全排列","slug":"全排列","date":"2019-06-24T16:28:25.000Z","updated":"2019-06-24T16:35:52.000Z","comments":true,"path":"2019/06/25/全排列/","link":"","permalink":"http://yoursite.com/2019/06/25/全排列/","excerpt":"","text":"12345678910111213141516171819202122232425262728293031323334//全排列 #if 0#include&lt;bits/stdc++.h&gt;using namespace std;void fun(int a[],int k,int m)&#123; if(k == m) &#123; for(int i=0; i&lt;=m; i++) cout&lt;&lt;a[i]&lt;&lt;\" \"; cout&lt;&lt;endl; &#125; for(int i=k; i&lt;=m; i++) &#123; swap(a[k],a[i]); fun(a,k+1,m); swap(a[k],a[i]); &#125;&#125;int main()&#123; int n; int a[100]; cin&gt;&gt;n; for(int i=0; i&lt;n; i++) &#123; cin&gt;&gt;a[i]; &#125; fun(a,0,n-1); &#125;#endif","categories":[],"tags":[{"name":"算法","slug":"算法","permalink":"http://yoursite.com/tags/算法/"}]},{"title":"动态规划","slug":"动态规划","date":"2019-06-24T16:21:13.000Z","updated":"2019-07-26T05:17:46.000Z","comments":true,"path":"2019/06/25/动态规划/","link":"","permalink":"http://yoursite.com/2019/06/25/动态规划/","excerpt":"","text":"12345678910111213141516171819202122232425262728291.KMP/*KMP算法 查询字符串a中 是否包含 字符串b ababcabcacbababcac*/ void getNext(string str) &#123; int k = 0; for (int i = 1; i &lt; str.size(); i++) &#123; while (k &gt; 0 &amp;&amp; str[i] != str[k]) k = next[k-1]; //精髓 if (str[i] == str[k]) k++; next[i] = k; &#125;&#125; int kmp(string s1, string s2) &#123; int i = 0, j = 0; for (i = 0; i &lt; s1.size() &amp;&amp; j &lt; s2.size(); i++) &#123; if (s1[i] == s2[j]) &#123; j++; &#125; else &#123; j = next[j-1]; //需要感受 &#125; &#125; if (j == s2.size()) return i - s2.size(); //返回第一次匹配的的下标 return -1; &#125; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647482.背包问题 // 01背包问题 // f[i][j]代表了 前i个物品的时候 容量为j的时候的最大的价值量，其中j必须是从v ...0的，因为每一个物品要选一次！！！ &#123; int m,n; //m:背包的容量 n:物品的个数 cin&gt;&gt;m&gt;&gt;n; int w[n+10]; //每个物品的重量 int c[n+10]; //每个物品的价值 int f[m+10]; //f[k]代表 k个物品的时候，能装的最大的价值 memset(f,0,sizeof(f)); for(int i=0; i&lt;n; i++) &#123; cin&gt;&gt;w[i]&gt;&gt;c[i]; &#125; for(int i=0; i&lt;n; i++) &#123; for(int v = m; v&gt;=w[i]; v--) &#123; f[v] = max(f[v],f[v-w[i]] + c[i]); &#125; &#125; cout&lt;&lt;f[m]&lt;&lt;endl; &#125;//完全背包问题&#123; int m,n; //m:背包的容量 n:物品的个数 cin&gt;&gt;m&gt;&gt;n; int w[n+10]; //每个物品的重量 int c[n+10]; //每个物品的价值 int f[m+10]; //f[k]代表 k个物品的时候，能装的最大的价值 memset(f,0,sizeof(f)); for(int i=0; i&lt;n; i++) &#123; cin&gt;&gt;w[i]&gt;&gt;c[i]; &#125; for(int i=0; i&lt;n; i++) &#123; for(int v = w[i]; v&lt;=m; v++) &#123; f[v] = max(f[v],f[v-w[i]] + c[i]); &#125; &#125; cout&lt;&lt;f[m]&lt;&lt;endl;&#125; 1234567891011121314151617181920212223242526273.最大上升 子序列 /*给出 [4,2,4,5,3,7]，LIS 是 [2,4,5,7]，返回 4*/int fun(int a[],int n)&#123; int b[n]; //截至到i 最大的上升子序列 的个数 for(int i=0; i&lt;n; i++) b[i] = 1; for(int i=1; i&lt;n; i++) &#123; int max = -1; for(int j=0; j&lt;i; j++) //找出前面比 此时的x 小的，并且 连续数最 大的 ~！！！ &#123; if(a[j] &lt; a[i] &amp;&amp; b[j] &gt; max) &#123; max = b[j]; &#125; &#125; if(max != -1) b[i] = max +1; &#125; int maxx = 0; for(int i=0; i&lt;n; i++) maxx = max(b[i],maxx); return maxx;&#125; 1234567891011121314151617最大子数组和4.&#123; int a[] = &#123;1, -2, 3, -4, 5, 6, -7&#125;; int n = sizeof(a) / sizeof(int); int max = INT_MIN; int k = INT_MIN; for (int i = 0; i &lt; n; i++) &#123; if (k &gt; 0) &#123; k += a[i]; &#125; else &#123; k = a[i]; &#125; if (k &gt; max) &#123; max = k; &#125; &#125; &#125;","categories":[],"tags":[{"name":"算法","slug":"算法","permalink":"http://yoursite.com/tags/算法/"}]},{"title":"排序算法","slug":"排序算法","date":"2019-06-24T16:13:54.000Z","updated":"2019-06-24T16:32:16.000Z","comments":true,"path":"2019/06/25/排序算法/","link":"","permalink":"http://yoursite.com/2019/06/25/排序算法/","excerpt":"","text":"12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182//排序算法有 冒泡 / 快排/ 选择/堆排序/ 归并 / 桶排序 ///1.冒泡排序#if 0#include&lt;bits/stdc++.h&gt;using namespace std;void sort(int a[],int n)&#123; for(int i=0; i&lt;n-1; i++) &#123; for(int j=0; j&lt;n-i-1; j++) // &#123; if(a[j] &gt; a[j+1]) swap(a[j],a[j+1]); &#125; &#125; &#125;int main()&#123; int a[1000]; int n; cin&gt;&gt;n; for(int i=0; i&lt;n; i++) cin&gt;&gt;a[i]; sort(a,n); for(int i=0; i&lt;n; i++) cout&lt;&lt;a[i]&lt;&lt;\" \"; &#125;#endif //1.1 快速排序 #if 0#include&lt;bits/stdc++.h&gt;using namespace std;int a[1000];int pattern(int l,int r)&#123; int i = l,j = r; while(i&lt;j) &#123; while(i&lt;j &amp;&amp; a[i]&lt;=a[j]) j--; if(i&lt;j) swap(a[i],a[j]); while(i&lt;j &amp;&amp; a[i]&lt;=a[j]) i++; if(i&lt;j) swap(a[i],a[j]); &#125; return i;&#125;void sort(int i,int j)&#123; if(i&lt;j) &#123; int mid = pattern(i,j); sort(i,mid-1); sort(mid+1,j); &#125;&#125;int main()&#123; int n; cin&gt;&gt;n; for(int i=0; i&lt;n; i++) cin&gt;&gt;a[i]; sort(0,n-1); for(int i=0; i&lt;n; i++) cout&lt;&lt;a[i]&lt;&lt;\" \"; &#125;#endif 123456789101112131415161718192021222324252627282930313233343536//2.选择排序#if 0#include&lt;bits/stdc++.h&gt;using namespace std;void sort(int a[],int n)&#123; int num; for(int i=0; i&lt;n-1; i++) &#123; num = i; for(int j=i+1; j&lt;n; j++) &#123; if(a[j] &gt; a[num]) num = j; &#125; if(num != i) swap(a[num],a[i]); &#125; &#125;int main()&#123; int a[1000]; int n; cin&gt;&gt;n; for(int i=0; i&lt;n; i++) cin&gt;&gt;a[i]; sort(a,n); for(int i=0; i&lt;n; i++) cout&lt;&lt;a[i]&lt;&lt;\" \"; &#125;#endif 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556//3. 归并排序#if 0#include&lt;bits/stdc++.h&gt;using namespace std;int r[1000],r1[1000];void merge(int s,int m,int t)&#123; int i=s,j=m+1,k=s; while(i&lt;=m &amp;&amp; j&lt;=t) &#123; if(r[i]&lt;=r[j]) r1[k++] = r[i++]; else r1[k++] = r[j++]; &#125; while(i&lt;=m) r1[k++] = r[i++]; while(j&lt;=t) r1[k++] = r[j++]; for(int z=s; z&lt;=t; z++) r[z] = r1[z]; &#125;void sort(int s,int t)&#123; if(s&gt;=t) return; int m = (s+t)/2; sort(s,m); sort(m+1,t); merge(s,m,t);&#125;int main()&#123; int n; cin&gt;&gt;n; for(int i=0; i&lt;n; i++) &#123; cin&gt;&gt;r[i]; &#125; sort(0,n-1); for(int i=0; i&lt;n; i++) cout&lt;&lt;r1[i]&lt;&lt;\" \"; &#125;#endif 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960//4.堆排序#if 0#include&lt;bits/stdc++.h&gt;using namespace std;int a[100000];int n;void sift(int s,int t)&#123; int i=s,j=2*s; while(j&lt;=t) &#123; if(a[j+1] &gt; a[j] &amp;&amp; j&lt;t) j++; if(a[i] &gt; a[j]) break; else &#123; swap(a[i],a[j]); i = j; j = 2*i; &#125; &#125;&#125;void sort(int n)&#123; for(int i=n/2; i&gt;=1; i--) &#123; sift(i,n); &#125; for(int i=1; i&lt;n; i++) &#123; swap(a[1],a[n-i+1]); sift(1,n-i); &#125;&#125;int main()&#123; cin&gt;&gt;n; for(int i=1; i&lt;=n; i++) &#123; a[i] = n-i; &#125; sort(n); for(int i=1; i&lt;=n; i++) cout&lt;&lt;a[i]&lt;&lt;\" \"; &#125;#endif 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101//基数排序#if 0#include&lt;bits/stdc++.h&gt;using namespace std;int head;struct Node&#123; int key; int next;&#125;;struct QueueNode&#123; int front,rear;&#125;;void distribute(Node r[],int n,QueueNode q[],int m)&#123; int i = 0; //默认为0 最后的next为 -1 while(1) &#123; int key = r[i].key; if(q[key].front==-1) &#123; q[key].front = i; &#125; else &#123; r[q[key].rear].next = i; &#125; q[key].rear = i; i = r[i].next; if(i == -1) break; &#125; &#125;void collection(Node r[],int n,QueueNode q[],int m)&#123; int k = 0; while(q[k].front==-1) k++; int first = q[k].front; int last = q[k].rear; head = first; while(k&lt;m) &#123; k++; if(q[k].front!=-1) &#123; r[last].next = q[k].front; last = q[k].rear; &#125; &#125; r[last].next = -1;&#125;void bucketSort(Node r[],int n,QueueNode q[],int m)&#123; for(int i=0; i&lt;n; i++) r[i].next = i+1; r[n-1].next = -1; for(int i=0; i&lt;m; i++) &#123; q[i].front = q[i].rear = -1; &#125; distribute(r,n,q,m); collection(r,n,q,m); &#125;int main()&#123; Node r[1000]; QueueNode q[1000]; int n; cin&gt;&gt;n; for(int i=0; i&lt;n; i++) r[i].key = n-i; bucketSort(r,n,q,100); while(head!=-1) &#123; cout&lt;&lt;r[head].key&lt;&lt;\" \"; head = r[head].next; &#125; &#125;#endif 12345678910111213141516171819202122232425262728293031323334//插入排序#if 0#include&lt;bits/stdc++.h&gt;using namespace std;void sort(int a[],int n)&#123; for(int i=2; i&lt;=n; i++) &#123; a[0] = a[i]; int j; for(j=i-1; a[j] &gt; a[0]; j--) &#123; a[j+1] = a[j]; &#125; a[j+1] = a[0]; &#125;&#125;int main()&#123; int a[100]; int n; cin&gt;&gt;n; for(int i=1; i&lt;=n; i++) cin&gt;&gt;a[i]; sort(a,n); for(int i=1; i&lt;=n; i++) cout&lt;&lt;a[i]&lt;&lt;\" \"; &#125;#endif 123456789101112131415161718192021222324252627282930313233343536//希尔排序#if 0 #include&lt;bits/stdc++.h&gt;using namespace std;void sort(int a[],int n)&#123; for(int d=n/2; d&gt;=1; d/=2) &#123; for(int i=d+1; i&lt;=n; i++) &#123; a[0] = a[i]; int j; for(j=i-d; j&gt;0&amp;&amp;a[0]&lt;a[j]; j-=d) &#123; a[j+d] = a[j]; &#125; a[j+d] = a[0]; &#125; &#125;&#125;int main()&#123; int a[100]; int n; cin&gt;&gt;n; for(int i=1; i&lt;=n; i++) cin&gt;&gt;a[i]; sort(a,n); for(int i=1; i&lt;=n; i++) cout&lt;&lt;a[i]&lt;&lt;\" \";&#125;#endif","categories":[],"tags":[{"name":"算法","slug":"算法","permalink":"http://yoursite.com/tags/算法/"}]},{"title":"Http","slug":"Http状态码","date":"2019-06-24T15:41:23.000Z","updated":"2019-08-17T03:30:00.000Z","comments":true,"path":"2019/06/24/Http状态码/","link":"","permalink":"http://yoursite.com/2019/06/24/Http状态码/","excerpt":"","text":"—————-&gt;网站：Http学习请求头|响应头 1.信息代码：1xx，2.成功代码：2xx，3.重定向：3xx，4.客户端错误：4xx，5.服务器错误：5xx ============================================================================= HTTP: Status 1xx (临时响应)表示临时响应并需要请求者继续执行操作的状态代码。详细代码及说明: HTTP: Status 100 (继续)-&gt;请求者应当继续提出请求。 服务器返回此代码表示已收到请求的第一部分，正在等待其余部分。HTTP: Status 101 (切换协议)-&gt;请求者已要求服务器切换协议，服务器已确认并准备切换。 HTTP Status 2xx (成功)表示成功处理了请求的状态代码;详细代码及说明: HTTP Status 200 (成功)-&gt; 服务器已成功处理了请求。 通常，这表示服务器提供了请求的网页。HTTP Status 201 (已创建)-&gt; 请求成功并且服务器创建了新的资源。HTTP Status 202 (已接受)-&gt; 服务器已接受请求，但尚未处理。HTTP Status 203 (非授权信息)-&gt; 服务器已成功处理了请求，但返回的信息可能来自另一来源。HTTP Status 204 (无内容)-&gt; 服务器成功处理了请求，但没有返回任何内容。HTTP Status 205 (重置内容)-&gt; 服务器成功处理了请求，但没有返回任何内容。HTTP Status 206 (部分内容)-&gt; 服务器成功处理了部分 GET 请求。 HTTP Status 3xx （重定向）常见的代码 300 （多种选择） 针对请求，服务器可执行多种操作。 服务器可根据请求者 (user agent) 选择一项操作，或提供操作列表供请求者选择。301 （永久移动） 请求的网页已永久移动到新位置。 服务器返回此响应（对 GET 或 HEAD 请求的响应）时，会自动将请求者转到新位置。302 （临时移动） 服务器目前从不同位置的网页响应请求，但请求者应继续使用原有位置来进行以后的请求。303 （查看其他位置） 请求者应当对不同的位置使用单独的 GET 请求来检索响应时，服务器返回此代码。304 （未修改） 自从上次请求后，请求的网页未修改过。 服务器返回此响应时，不会返回网页内容。305 （使用代理） 请求者只能使用代理访问请求的网页。 如果服务器返回此响应，还表示请求者应使用代理。307 （临时重定向） 服务器目前从不同位置的网页响应请求，但请求者应继续使用原有位置来进行以后的请求。 HTTP Status 4xx (请求错误)-&gt;这些状态代码表示请求可能出错，妨碍了服务器的处理。 详细代码说明:HTTP Status 400 （错误请求）-&gt;服务器不理解请求的语法。HTTP Status 401 （未授权）-&gt;请求要求身份验证。 对于需要登录的网页，服务器可能返回此响应。HTTP Status 403 （禁止）-&gt; 服务器拒绝请求。HTTP Status 404 （未找到）-&gt;服务器找不到请求的网页。HTTP Status 405 （方法禁用）-&gt;禁用请求中指定的方法。HTTP Status 406 （不接受）-&gt;无法使用请求的内容特性响应请求的网页。HTTP Status 407 （需要代理授权）-&gt;此状态代码与 401（未授权）类似，但指定请求者应当授权使用代理。HTTP Status 408 （请求超时）-&gt;服务器等候请求时发生超时。HTTP Status 409 （冲突）-&gt;服务器在完成请求时发生冲突。 服务器必须在响应中包含有关冲突的信息。HTTP Status 410 （已删除）-&gt; 如果请求的资源已永久删除，服务器就会返回此响应。HTTP Status 411 （需要有效长度）-&gt;服务器不接受不含有效内容长度标头字段的请求。HTTP Status 412 （未满足前提条件）-&gt;服务器未满足请求者在请求中设置的其中一个前提条件。HTTP Status 413 （请求实体过大）-&gt;服务器无法处理请求，因为请求实体过大，超出服务器的处理能力。HTTP Status 414 （请求的 URI 过长） 请求的 URI（通常为网址）过长，服务器无法处理。HTTP Status 415 （不支持的媒体类型）-&gt;请求的格式不受请求页面的支持。HTTP Status 416 （请求范围不符合要求）-&gt;如果页面无法提供请求的范围，则服务器会返回此状态代码。HTTP Status 417 （未满足期望值）-&gt;服务器未满足”期望”请求标头字段的要求。 HTTP Status 5xx （服务器错误）-&gt;这些状态代码表示服务器在尝试处理请求时发生内部错误。 这些错误可能是服务器本身的错误，而不是请求出错。代码详细及说明:HTTP Status 500 （服务器内部错误）-&gt;服务器遇到错误，无法完成请求。HTTP Status 501 （尚未实施）-&gt;服务器不具备完成请求的功能。 例如，服务器无法识别请求方法时可能会返回此代码。HTTP Status 502 （错误网关）-&gt;服务器作为网关或代理，从上游服务器收到无效响应。HTTP Status 503 （服务不可用）-&gt; 服务器目前无法使用（由于超载或停机维护）。 通常，这只是暂时状态。HTTP Status 504 （网关超时）-&gt;服务器作为网关或代理，但是没有及时从上游服务器收到请求。HTTP Status 505 （HTTP 版本不受支持）-&gt; 服务器不支持请求中所用的 HTTP 协议版本。","categories":[],"tags":[{"name":"计算机网络","slug":"计算机网络","permalink":"http://yoursite.com/tags/计算机网络/"}]},{"title":"网络端口号","slug":"端口号","date":"2019-06-24T07:01:10.000Z","updated":"2019-06-24T15:54:38.000Z","comments":true,"path":"2019/06/24/端口号/","link":"","permalink":"http://yoursite.com/2019/06/24/端口号/","excerpt":"","text":"21/tcp FTP 文件传输协议22/tcp SSH 安全登录、文件传送(SCP)和端口重定向23/tcp Telnet 不安全的文本传送25/tcp SMTP Simple Mail Transfer Protocol (E-mail)69/udp TFTP Trivial File Transfer Protocol79/tcp finger Finger80/tcp HTTP 超文本传送协议 (WWW)88/tcp Kerberos Authenticating agent110/tcp POP3 Post Office Protocol (E-mail)113/tcp ident old identification server system119/tcp NNTP used for usenet newsgroups220/tcp IMAP3443/tcp HTTPS used for securely transferring web pages端口：0服务：Reserved说明：通常用于分析操作系统。这一方法能够工作是因为在一些系统中“0”是无效端口，当你试图使用通常的闭合端口连接它时将产生不同的结果。一种典型的扫描，使用IP地址为0.0.0.0，设置ACK位并在以太网层广播。 端口：1服务：tcpmux说明：这显示有人在寻找SGI Irix机器。Irix是实现tcpmux的主要提供者，默认情况下tcpmux在这种系统中被打开。Irix机器在发布是含有几个默认的无密码的帐户，如：IP、GUEST UUCP、NUUCP、DEMOS 、TUTOR、DIAG、OUTOFBOX等。许多管理员在安装后忘记删除这些帐户。因此HACKER在INTERNET上搜索tcpmux并利用这些帐户。 端口：7服务：Echo说明：能看到许多人搜索Fraggle放大器时，发送到X.X.X.0和X.X.X.255的信息。 端口：19服务：Character Generator说明：这是一种仅仅发送字符的服务。UDP版本将会在收到UDP包后回应含有垃圾字符的包。TCP连接时会发送含有垃圾字符的数据流直到连接关闭。HACKER利用IP欺骗可以发动DoS攻击。伪造两个chargen服务器之间的UDP包。同样Fraggle DoS攻击向目标地址的这个端口广播一个带有伪造受害者IP的数据包，受害者为了回应这些数据而过载。 端口：21服务：FTP说明：FTP服务器所开放的端口，用于上传、下载。最常见的攻击者用于寻找打开anonymous的FTP服务器的方法。这些服务器带有可读写的目录。木马Doly Trojan、Fore、Invisible FTP、WebEx、WinCrash和Blade Runner所开放的端口。 端口：22服务：Ssh说明：PcAnywhere建立的TCP和这一端口的连接可能是为了寻找ssh。这一服务有许多弱点，如果配置成特定的模式，许多使用RSAREF库的版本就会有不少的漏洞存在。 端口：23服务：Telnet说明：远程登录，入侵者在搜索远程登录UNIX的服务。大多数情况下扫描这一端口是为了找到机器运行的操作系统。还有使用其他技术，入侵者也会找到密码。木马Tiny Telnet Server就开放这个端口。 端口：25服务：SMTP说明：SMTP服务器所开放的端口，用于发送邮件。入侵者寻找SMTP服务器是为了传递他们的SPAM。入侵者的帐户被关闭，他们需要连接到高带宽的E-MAIL服务器上，将简单的信息传递到不同的地址。木马Antigen、Email Password Sender、Haebu Coceda、Shtrilitz Stealth、WinPC、WinSpy都开放这个端口。 端口：31服务：MSG Authentication说明：木马Master Paradise、Hackers Paradise开放此端口。 端口：42服务：WINS Replication说明：WINS复制 端口：53服务：Domain Name Server（DNS）说明：DNS服务器所开放的端口，入侵者可能是试图进行区域传递（TCP），欺骗DNS（UDP）或隐藏其他的通信。因此防火墙常常过滤或记录此端口。端口：67服务：Bootstrap Protocol Server说明：通过DSL和Cable modem的防火墙常会看见大量发送到广播地址255.255.255.255的数据。这些机器在向DHCP服务器请求一个地址。HACKER常进入它们，分配一个地址把自己作为局部路由器而发起大量中间人（man-in-middle）攻击。客户端向68端口广播请求配置，服务器向67端口广播回应请求。这种回应使用广播是因为客户端还不知道可以发送的IP地址。 端口：69服务：Trival File Transfer说明：许多服务器与bootp一起提供这项服务，便于从系统下载启动代码。但是它们常常由于错误配置而使入侵者能从系统中窃取任何 文件。它们也可用于系统写入文件。 端口：79服务：Finger Server说明：入侵者用于获得用户信息，查询操作系统，探测已知的缓冲区溢出错误，回应从自己机器到其他机器Finger扫描。 端口：80服务：HTTP说明：用于网页浏览。木马Executor开放此端口。 端口：99服务：gram Relay说明：后门程序ncx99开放此端口。 端口：102服务：Message transfer agent(MTA)-X.400 over TCP/IP说明：消息传输代理。 端口：109服务：Post Office Protocol -Version3说明：POP3服务器开放此端口，用于接收邮件，客户端访问服务器端的邮件服务。POP3服务有许多公认的弱点。关于用户名和密码交 换缓冲区溢出的弱点至少有20个，这意味着入侵者可以在真正登陆前进入系统。成功登陆后还有其他缓冲区溢出错误。 端口：110服务：SUN公司的RPC服务所有端口说明：常见RPC服务有rpc.mountd、NFS、rpc.statd、rpc.csmd、rpc.ttybd、amd等 端口：113服务：Authentication Service说明：这是一个许多计算机上运行的协议，用于鉴别TCP连接的用户。使用标准的这种服务可以获得许多计算机的信息。但是它可作为许多服务的记录器，尤其是FTP、POP、IMAP、SMTP和IRC等服务。通常如果有许多客户通过防火墙访问这些服务，将会看到许多这个端口的连接请求。记住，如果阻断这个端口客户端会感觉到在防火墙另一边与E-MAIL服务器的缓慢连接。许多防火墙支持TCP连接的阻断过程中发回RST。这将会停止缓慢的连接。端口：119服务：Network News Transfer Protocol说明：NEWS新闻组传输协议，承载USENET通信。这个端口的连接通常是人们在寻找USENET服务器。多数ISP限制，只有他们的客户才能访问他们的新闻组服务器。打开新闻组服务器将允许发/读任何人的帖子，访问被限制的新闻组服务器，匿名发帖或发送SPAM。 端口：135服务：Location Service说明：Microsoft在这个端口运行DCE RPC end-point mapper为它的DCOM服务。这与UNIX 111端口的功能很相似。使用DCOM和RPC的服务利用计算机上的end-point mapper注册它们的位置。远端客户连接到计算机时，它们查找end-point mapper找到服务的位置。HACKER扫描计算机的这个端口是为了找到这个计算机上运行Exchange Server吗？什么版本？还有些DOS攻击直接针对这个端口。 端口：137、138、139服务：NETBIOS Name Service说明：其中137、138是UDP端口，当通过网上邻居传输文件时用这个端口。而139端口：通过这个端口进入的连接试图获得NetBIOS/SMB服务。这个协议被用于windows文件和打印机共享和SAMBA。还有WINS Regisrtation也用它。 端口：143服务：Interim Mail Access Protocol v2说明：和POP3的安全问题一样，许多IMAP服务器存在有缓冲区溢出漏洞。记住：一种LINUX蠕虫（admv0rm）会通过这个端口繁殖，因此许多这个端口的扫描来自不知情的已经被感染的用户。当REDHAT在他们的LINUX发布版本中默认允许IMAP后，这些漏洞变的很流行。这一端口还被用于IMAP2，但并不流行。 端口：161服务：SNMP说明：SNMP允许远程管理设备。所有配置和运行信息的储存在数据库中，通过SNMP可获得这些信息。许多管理员的错误配置将被暴露在Internet。Cackers将试图使用默认的密码public、private访问系统。他们可能会试验所有可能的组合。SNMP包可能会被错误的指向用户的网络。 端口：177服务：X Display Manager Control Protocol说明：许多入侵者通过它访问X-windows操作台，它同时需要打开6000端口。 端口：389服务：LDAP、ILS说明：轻型目录访问协议和NetMeeting Internet Locator Server共用这一端口。 端口：443服务：Https说明：网页浏览端口，能提供加密和通过安全端口传输的另一种HTTP。 端口：456服务：[NULL]说明：木马HACKERS PARADISE开放此端口。 端口：513服务：Login,remote login说明：是从使用cable modem或DSL登陆到子网中的UNIX计算机发出的广播。这些人为入侵者进入他们的系统提供了信息。 端口：544服务：[NULL]说明：kerberos kshell 端口：548服务：Macintosh,File Services(AFP/IP)说明：Macintosh,文件服务。 端口：553服务：CORBA IIOP （UDP）说明：使用cable modem、DSL或VLAN将会看到这个端口的广播。CORBA是一种面向对象的RPC系统。入侵者可以利用这些信息进入系统。 端口：555服务：DSF说明：木马PhAse1.0、Stealth Spy、IniKiller开放此端口。端口：568服务：Membership DPA说明：成员资格 DPA。 端口：569服务：Membership MSN说明：成员资格 MSN。 端口：635服务：mountd说明：Linux的mountd Bug。这是扫描的一个流行BUG。大多数对这个端口的扫描是基于UDP的，但是基于TCP的mountd有所增加（mountd同时运行于两个端口）。记住mountd可运行于任何端口（到底是哪个端口，需要在端口111做portmap查询），只是Linux默认端口是635，就像NFS通常运行于2049端口。 端口：636服务：LDAP说明：SSL（Secure Sockets layer） 端口：666服务：Doom Id Software说明：木马Attack FTP、Satanz Backdoor开放此端口 端口：993服务：IMAP说明：SSL（Secure Sockets layer） 端口：1001、1011服务：[NULL]说明：木马Silencer、WebEx开放1001端口。木马Doly Trojan开放1011端口。 端口：1024服务：Reserved说明：它是动态端口的开始，许多程序并不在乎用哪个端口连接网络，它们请求系统为它们分配下一个闲置端口。基于这一点分配从端口1024开始。这就是说第一个向系统发出请求的会分配到1024端口。你可以重启机器，打开Telnet，再打开一个窗口运行natstat -a 将会看到Telnet被分配1024端口。还有SQL session也用此端口和5000端口。 端口：1025、1033服务：1025：network blackjack 1033：[NULL]说明：木马netspy开放这2个端口。 端口：1080服务：SOCKS说明：这一协议以通道方式穿过防火墙，允许防火墙后面的人通过一个IP地址访问INTERNET。理论上它应该只允许内部的通信向外到达INTERNET。但是由于错误的配置，它会允许位于防火墙外部的攻击穿过防火墙。WinGate常会发生这种错误，在加入IRC聊天室时常会看到这种情况。 端口：1170服务：[NULL]说明：木马Streaming Audio Trojan、Psyber Stream Server、Voice开放此端口。 端口：1234、1243、6711、6776服务：[NULL]说明：木马SubSeven2.0、Ultors Trojan开放1234、6776端口。木马SubSeven1.0/1.9开放1243、6711、6776端口。 端口：1245服务：[NULL]说明：木马Vodoo开放此端口。 端口：1433服务：SQL说明：Microsoft的SQL服务开放的端口。 端口：1492服务：stone-design-1说明：木马FTP99CMP开放此端口。 端口：1500服务：RPC client fixed port session queries说明：RPC客户固定端口会话查询 端口：1503服务：NetMeeting T.120说明：NetMeeting T.120 端口：1524服务：ingress说明：许多攻击脚本将安装一个后门SHELL于这个端口，尤其是针对SUN系统中Sendmail和RPC服务漏洞的脚本。如果刚安装了防火墙就看到在这个端口上的连接企图，很可能是上述原因。可以试试Telnet到用户的计算机上的这个端口，看看它是否会给你一个SHELL。连接到600/pcserver也存在这个问题。 端口：1600服务：issd说明：木马Shivka-Burka开放此端口。 端口：1720服务：NetMeeting说明：NetMeeting H.233 call Setup。 端口：1731服务：NetMeeting Audio Call Control说明：NetMeeting音频调用控制。 端口：1807服务：[NULL]说明：木马SpySender开放此端口。 端口：1981服务：[NULL]说明：木马ShockRave开放此端口。 端口：1999服务：cisco identification port说明：木马BackDoor开放此端口。 端口：2000服务：[NULL]说明：木马GirlFriend 1.3、Millenium 1.0开放此端口。 端口：2001服务：[NULL]说明：木马Millenium 1.0、Trojan Cow开放此端口。 端口：2023服务：xinuexpansion 4说明：木马Pass Ripper开放此端口。 端口：2049服务：NFS说明：NFS程序常运行于这个端口。通常需要访问Portmapper查询这个服务运行于哪个端口。 端口：2115服务：[NULL]说明：木马Bugs开放此端口。 端口：2140、3150服务：[NULL]说明：木马Deep Throat 1.0/3.0开放此端口。 端口：2500服务：RPC client using a fixed port session replication说明：应用固定端口会话复制的RPC客户","categories":[],"tags":[{"name":"计算机网络","slug":"计算机网络","permalink":"http://yoursite.com/tags/计算机网络/"}]},{"title":"天津之行","slug":"天津之行","date":"2018-10-07T17:25:31.000Z","updated":"2018-10-08T09:33:48.000Z","comments":true,"path":"2018/10/08/天津之行/","link":"","permalink":"http://yoursite.com/2018/10/08/天津之行/","excerpt":"","text":"2018年的十一假期过去了，明天又要开始上课了，不对，是今天。忙碌了一个暑假做了小app，终于提交了小作品，哈！终于有了一个小假期，安排一手，顶着人流高峰，出去转一转。天津，怎么说，感觉那边的方言特别的有味道呢？对！就是说快板的味道，媒体在无形中给留下的影响还是蛮大的嘛。怎么说，在电视机旁看一场相声，真的不如来一场现场的来的有感觉！还有嘛，就是躺在秋天的草坪上面，旁边放着音乐，体会时间的悠闲哈！简单放两张图纪念一下。传说中的天津之眼，架在桥上的摩天轮真的有些许艺术感。","categories":[],"tags":[{"name":"杂谈","slug":"杂谈","permalink":"http://yoursite.com/tags/杂谈/"}]},{"title":"next主题","slug":"主题","date":"2018-05-11T14:42:36.000Z","updated":"2018-05-13T05:56:48.000Z","comments":true,"path":"2018/05/11/主题/","link":"","permalink":"http://yoursite.com/2018/05/11/主题/","excerpt":"","text":"这两天比较了yilia和next主题，最后还是选择了自我感觉比较酷next主题，从这中间也走了一些坑。1.克隆下来的主题，从git上克隆下来了一个不是最新版本的就是比较伤的事情了，突然发现主题的语言变成了德文–？看到git日志才发现最新的git版本的url。2.还有就是最初按照next官方文档配置的目录..发现官方文档也好久没有更新了，目录中的about、tags等都需要手动配置，拿about说一下，hexo new post”about”，然后在md里添加type: “about”，记得有空格啊。","categories":[],"tags":[{"name":"杂谈","slug":"杂谈","permalink":"http://yoursite.com/tags/杂谈/"}]},{"title":"hexo和Markdown的小用法","slug":"Hexo+Markdown","date":"2018-03-22T15:24:01.000Z","updated":"2020-06-30T11:25:40.485Z","comments":true,"path":"2018/03/22/Hexo+Markdown/","link":"","permalink":"http://yoursite.com/2018/03/22/Hexo+Markdown/","excerpt":"","text":"简单的用于博客的指令：hexo new post “the name of the file”hexo g 部署hexo shexo s –debughexo dhexo d -g Markdown1.标题设置： #字符用于控制标题大小 （一级也就是一个#最大）2.块注释：（blockquote） 通过在文字开头添加“&gt;”表示块注释 3.斜体： 将需要设置为斜体的文字两端使用1个星号 或者 ““夹起来 @zeroker4.粗体：将需要设置为斜体的文字两端使用2个”*”或者”“夹起来 @zeroker5.链接：内联方式：This is an [注释] (url).6.图片：! [alt text] [id]","categories":[],"tags":[{"name":"工具箱","slug":"工具箱","permalink":"http://yoursite.com/tags/工具箱/"}]},{"title":"博客搭建教程","slug":"教程","date":"2017-04-20T12:53:32.000Z","updated":"2018-05-11T14:15:16.000Z","comments":true,"path":"2017/04/20/教程/","link":"","permalink":"http://yoursite.com/2017/04/20/教程/","excerpt":"","text":"exciting AND 因吹斯汀 。点击-&gt;教程点击-&gt;markdow语法点击-&gt;window10快捷键 Open the world–&gt;topcoderopen the world–&gt;codeforces","categories":[],"tags":[{"name":"杂谈","slug":"杂谈","permalink":"http://yoursite.com/tags/杂谈/"}]}]}
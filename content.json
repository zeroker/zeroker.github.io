{"meta":{"title":"Q同學's world","subtitle":"千里之行，始于足下","description":"Make a diffence","author":"Q-同學","url":"http://yoursite.com"},"pages":[{"title":"about","date":"2018-05-10T12:57:47.000Z","updated":"2018-05-11T14:28:32.742Z","comments":true,"path":"about/index.html","permalink":"http://yoursite.com/about/index.html","excerpt":"","text":"座右铭： 千里之行，始于足下zeroker, 就读山农， 年轻的躯体 怀着一颗好奇的心 贫瘠的知识 仍需继续努力"},{"title":"categories","date":"2018-05-10T12:56:29.000Z","updated":"2018-05-10T12:56:48.664Z","comments":true,"path":"categories/index.html","permalink":"http://yoursite.com/categories/index.html","excerpt":"","text":""},{"title":"tags","date":"2018-05-10T12:54:10.000Z","updated":"2018-05-10T12:55:12.668Z","comments":true,"path":"tags/index.html","permalink":"http://yoursite.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"全排列","slug":"全排列","date":"2019-06-24T16:28:25.000Z","updated":"2019-06-24T16:35:51.005Z","comments":true,"path":"2019/06/25/全排列/","link":"","permalink":"http://yoursite.com/2019/06/25/全排列/","excerpt":"","text":"12345678910111213141516171819202122232425262728293031323334//全排列 #if 0#include&lt;bits/stdc++.h&gt;using namespace std;void fun(int a[],int k,int m)&#123; if(k == m) &#123; for(int i=0; i&lt;=m; i++) cout&lt;&lt;a[i]&lt;&lt;\" \"; cout&lt;&lt;endl; &#125; for(int i=k; i&lt;=m; i++) &#123; swap(a[k],a[i]); fun(a,k+1,m); swap(a[k],a[i]); &#125;&#125;int main()&#123; int n; int a[100]; cin&gt;&gt;n; for(int i=0; i&lt;n; i++) &#123; cin&gt;&gt;a[i]; &#125; fun(a,0,n-1); &#125;#endif","categories":[],"tags":[{"name":"算法","slug":"算法","permalink":"http://yoursite.com/tags/算法/"}]},{"title":"dp","slug":"动态规划","date":"2019-06-24T16:21:13.000Z","updated":"2019-06-24T16:33:23.292Z","comments":true,"path":"2019/06/25/动态规划/","link":"","permalink":"http://yoursite.com/2019/06/25/动态规划/","excerpt":"","text":"1234567891011121314151617181920212223242526272829303132333435363738391.最大上升 子序列 /*给出 [4,2,4,5,3,7]，LIS 是 [2,4,5,7]，返回 4*/#if 0#include&lt;bits/stdc++.h&gt;using namespace std;int fun(int a[],int n)&#123; int b[n]; //截至到i 最大的上升子序列 的个数 for(int i=0; i&lt;n; i++) b[i] = 1; for(int i=1; i&lt;n; i++) &#123; int max = -1; for(int j=0; j&lt;i; j++) //找出前面比 此时的x 小的，并且 连续数最 大的 ~！！！ &#123; if(a[j] &lt; a[i] &amp;&amp; b[j] &gt; max) &#123; max = b[j]; &#125; &#125; if(max != -1) b[i] = max +1; &#125; int maxx = 0; for(int i=0; i&lt;n; i++) maxx = max(b[i],maxx); return maxx;&#125;int main()&#123; int n = 5;// int a[] =&#123;4,2,4,5,3,7&#125;; //5,4,1,2,3 int a[] =&#123;5,4,1,2,3&#125;; cout&lt;&lt;fun(a,n)&lt;&lt;endl;&#125;#endif 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758592.背包问题 // 01背包问题 // f[i][j]代表了 前i个物品的时候 容量为j的时候的最大的价值量，其中j必须是从v ...0的，因为每一个物品要选一次！！！ #if 0 #include&lt;iostream&gt;#include&lt;bits/stdc++.h&gt;using namespace std;int main()&#123; int m,n; //m:背包的容量 n:物品的个数 cin&gt;&gt;m&gt;&gt;n; int w[n+10]; //每个物品的重量 int c[n+10]; //每个物品的价值 int f[m+10]; //f[k]代表 k个物品的时候，能装的最大的价值 memset(f,0,sizeof(f)); for(int i=0; i&lt;n; i++) &#123; cin&gt;&gt;w[i]&gt;&gt;c[i]; &#125; for(int i=0; i&lt;n; i++) &#123; for(int v = m; v&gt;=w[i]; v--) &#123; f[v] = max(f[v],f[v-w[i]] + c[i]); &#125; &#125; cout&lt;&lt;f[m]&lt;&lt;endl; &#125;#endif//完全背包问题#if 0#include&lt;bits/stdc++.h&gt;using namespace std;int main()&#123; int m,n; //m:背包的容量 n:物品的个数 cin&gt;&gt;m&gt;&gt;n; int w[n+10]; //每个物品的重量 int c[n+10]; //每个物品的价值 int f[m+10]; //f[k]代表 k个物品的时候，能装的最大的价值 memset(f,0,sizeof(f)); for(int i=0; i&lt;n; i++) &#123; cin&gt;&gt;w[i]&gt;&gt;c[i]; &#125; for(int i=0; i&lt;n; i++) &#123; for(int v = w[i]; v&lt;=m; v++) &#123; f[v] = max(f[v],f[v-w[i]] + c[i]); &#125; &#125; cout&lt;&lt;f[m]&lt;&lt;endl;&#125;#endif 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798991001011021031041051061071081091101111121131141151161171181191201211221231241251261271281291301311321331341351361371381391401411421431443.KMP/*KMP算法 查询字符串a中 是否包含 字符串b ababcabcacbababcac*/#if 1#include&lt;iostream&gt;#include&lt;cstring&gt;using namespace std;//笨办法得到next数组 void getNext(int next[],string s)&#123; memset(next,0,sizeof(next)); for(int i=0; i&lt;s.size(); i++) &#123; int ans = 0; string str = s.substr(0,i+1); for(int j=0; j&lt;str.size()-1; j++) &#123; string str1 = str.substr(0,j+1); string str2 = str.substr(str.size()-j-1,str.size()); if(str1==str2) &#123; ans = j+1; &#125; &#125; next[i] = ans; &#125;&#125; //a 是主字符串 b是小字符串 int kmp(string a,string b,int next[])&#123; int n = a.size() , i = 0; //主字符串的长度，主字符串的下标 int m = b.size() , j = 0; //小字符串的长度，已经匹配的个数 while(i &lt; n) &#123; if(j==0) //如果小字符串中的第一个元素没有找到与大字符串中有匹配的，那就寻找=== &#123; if(a[i] == b[j]) &#123; j++; //已经匹配的个数 &#125; else &#123; i++; //主字符串的 下标 &#125; &#125;else&#123; //已经有匹配的了 if(a[i+1] != b[j]) //如果不下一个字符不相等，那就移动小字符串，这个过程操作起来就是更改小字符串的下标。 &#123; j = next[j-1]; &#125; if(a[i+1] == b[j]) //如果相等那就比较下一个字符 &#123; i++; j++; &#125; &#125; if(j == m) //如果小字符串全比较完了，那就是全匹配了，完成！ 否则大字符串中不存在 小字符串！ return i; //这里返回小字符串在大字符串中最后匹配成功的字符的下标 &#125; return 0; &#125;int main()&#123; int next[1000]; string a = \"BBC ABCDAB ABCDABCDABDE\"; string b = \"ABCDABD\"; getNext(next,b); cout&lt;&lt;\"kmp:\"&lt;&lt;kmp(a,b,next)&lt;&lt;endl; &#125; #endif //求next数组/*ababc*/#if 0#include&lt;iostream&gt;#include&lt;cstring&gt;using namespace std;void getnext(string s,int next[])&#123; int n = s.size();//// for(int i=1; i&lt;n; i++)// &#123;// if(s[i] == s[next[i-1]])// next[i] = next[i-1] + 1;// &#125; memset(next,0,sizeof(next)); int k = 0; //k代表 最大前后缀长度 for(int i = 1,k = 0; i&lt;n; i++) &#123; while(k&gt;0 &amp;&amp; s[k] != s[i]) &#123; k = next[k-1]; &#125; if(s[i] == s[k]) &#123; k++; &#125; next[i] = k; &#125; &#125;int main()&#123; int next[100]; memset(next,0,sizeof(next));// string s = \"ABCDABD\";// string s = \"ababc\";// string s = \"abcdabcefabcd\"; string s = \"abadabab\"; int n = s.size(); getnext(s,next); for(int i=0; i&lt;n; i++) &#123; cout&lt;&lt;next[i]&lt;&lt;\" \"; &#125;&#125;#endif","categories":[],"tags":[{"name":"算法","slug":"算法","permalink":"http://yoursite.com/tags/算法/"}]},{"title":"排序算法","slug":"排序算法","date":"2019-06-24T16:13:54.000Z","updated":"2019-06-24T16:32:14.975Z","comments":true,"path":"2019/06/25/排序算法/","link":"","permalink":"http://yoursite.com/2019/06/25/排序算法/","excerpt":"","text":"12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182//排序算法有 冒泡 / 快排/ 选择/堆排序/ 归并 / 桶排序 ///1.冒泡排序#if 0#include&lt;bits/stdc++.h&gt;using namespace std;void sort(int a[],int n)&#123; for(int i=0; i&lt;n-1; i++) &#123; for(int j=0; j&lt;n-i-1; j++) // &#123; if(a[j] &gt; a[j+1]) swap(a[j],a[j+1]); &#125; &#125; &#125;int main()&#123; int a[1000]; int n; cin&gt;&gt;n; for(int i=0; i&lt;n; i++) cin&gt;&gt;a[i]; sort(a,n); for(int i=0; i&lt;n; i++) cout&lt;&lt;a[i]&lt;&lt;\" \"; &#125;#endif //1.1 快速排序 #if 0#include&lt;bits/stdc++.h&gt;using namespace std;int a[1000];int pattern(int l,int r)&#123; int i = l,j = r; while(i&lt;j) &#123; while(i&lt;j &amp;&amp; a[i]&lt;=a[j]) j--; if(i&lt;j) swap(a[i],a[j]); while(i&lt;j &amp;&amp; a[i]&lt;=a[j]) i++; if(i&lt;j) swap(a[i],a[j]); &#125; return i;&#125;void sort(int i,int j)&#123; if(i&lt;j) &#123; int mid = pattern(i,j); sort(i,mid-1); sort(mid+1,j); &#125;&#125;int main()&#123; int n; cin&gt;&gt;n; for(int i=0; i&lt;n; i++) cin&gt;&gt;a[i]; sort(0,n-1); for(int i=0; i&lt;n; i++) cout&lt;&lt;a[i]&lt;&lt;\" \"; &#125;#endif 123456789101112131415161718192021222324252627282930313233343536//2.选择排序#if 0#include&lt;bits/stdc++.h&gt;using namespace std;void sort(int a[],int n)&#123; int num; for(int i=0; i&lt;n-1; i++) &#123; num = i; for(int j=i+1; j&lt;n; j++) &#123; if(a[j] &gt; a[num]) num = j; &#125; if(num != i) swap(a[num],a[i]); &#125; &#125;int main()&#123; int a[1000]; int n; cin&gt;&gt;n; for(int i=0; i&lt;n; i++) cin&gt;&gt;a[i]; sort(a,n); for(int i=0; i&lt;n; i++) cout&lt;&lt;a[i]&lt;&lt;\" \"; &#125;#endif 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556//3. 归并排序#if 0#include&lt;bits/stdc++.h&gt;using namespace std;int r[1000],r1[1000];void merge(int s,int m,int t)&#123; int i=s,j=m+1,k=s; while(i&lt;=m &amp;&amp; j&lt;=t) &#123; if(r[i]&lt;=r[j]) r1[k++] = r[i++]; else r1[k++] = r[j++]; &#125; while(i&lt;=m) r1[k++] = r[i++]; while(j&lt;=t) r1[k++] = r[j++]; for(int z=s; z&lt;=t; z++) r[z] = r1[z]; &#125;void sort(int s,int t)&#123; if(s&gt;=t) return; int m = (s+t)/2; sort(s,m); sort(m+1,t); merge(s,m,t);&#125;int main()&#123; int n; cin&gt;&gt;n; for(int i=0; i&lt;n; i++) &#123; cin&gt;&gt;r[i]; &#125; sort(0,n-1); for(int i=0; i&lt;n; i++) cout&lt;&lt;r1[i]&lt;&lt;\" \"; &#125;#endif 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960//4.堆排序#if 0#include&lt;bits/stdc++.h&gt;using namespace std;int a[100000];int n;void sift(int s,int t)&#123; int i=s,j=2*s; while(j&lt;=t) &#123; if(a[j+1] &gt; a[j] &amp;&amp; j&lt;t) j++; if(a[i] &gt; a[j]) break; else &#123; swap(a[i],a[j]); i = j; j = 2*i; &#125; &#125;&#125;void sort(int n)&#123; for(int i=n/2; i&gt;=1; i--) &#123; sift(i,n); &#125; for(int i=1; i&lt;n; i++) &#123; swap(a[1],a[n-i+1]); sift(1,n-i); &#125;&#125;int main()&#123; cin&gt;&gt;n; for(int i=1; i&lt;=n; i++) &#123; a[i] = n-i; &#125; sort(n); for(int i=1; i&lt;=n; i++) cout&lt;&lt;a[i]&lt;&lt;\" \"; &#125;#endif 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101//基数排序#if 0#include&lt;bits/stdc++.h&gt;using namespace std;int head;struct Node&#123; int key; int next;&#125;;struct QueueNode&#123; int front,rear;&#125;;void distribute(Node r[],int n,QueueNode q[],int m)&#123; int i = 0; //默认为0 最后的next为 -1 while(1) &#123; int key = r[i].key; if(q[key].front==-1) &#123; q[key].front = i; &#125; else &#123; r[q[key].rear].next = i; &#125; q[key].rear = i; i = r[i].next; if(i == -1) break; &#125; &#125;void collection(Node r[],int n,QueueNode q[],int m)&#123; int k = 0; while(q[k].front==-1) k++; int first = q[k].front; int last = q[k].rear; head = first; while(k&lt;m) &#123; k++; if(q[k].front!=-1) &#123; r[last].next = q[k].front; last = q[k].rear; &#125; &#125; r[last].next = -1;&#125;void bucketSort(Node r[],int n,QueueNode q[],int m)&#123; for(int i=0; i&lt;n; i++) r[i].next = i+1; r[n-1].next = -1; for(int i=0; i&lt;m; i++) &#123; q[i].front = q[i].rear = -1; &#125; distribute(r,n,q,m); collection(r,n,q,m); &#125;int main()&#123; Node r[1000]; QueueNode q[1000]; int n; cin&gt;&gt;n; for(int i=0; i&lt;n; i++) r[i].key = n-i; bucketSort(r,n,q,100); while(head!=-1) &#123; cout&lt;&lt;r[head].key&lt;&lt;\" \"; head = r[head].next; &#125; &#125;#endif 12345678910111213141516171819202122232425262728293031323334//插入排序#if 0#include&lt;bits/stdc++.h&gt;using namespace std;void sort(int a[],int n)&#123; for(int i=2; i&lt;=n; i++) &#123; a[0] = a[i]; int j; for(j=i-1; a[j] &gt; a[0]; j--) &#123; a[j+1] = a[j]; &#125; a[j+1] = a[0]; &#125;&#125;int main()&#123; int a[100]; int n; cin&gt;&gt;n; for(int i=1; i&lt;=n; i++) cin&gt;&gt;a[i]; sort(a,n); for(int i=1; i&lt;=n; i++) cout&lt;&lt;a[i]&lt;&lt;\" \"; &#125;#endif 123456789101112131415161718192021222324252627282930313233343536//希尔排序#if 0 #include&lt;bits/stdc++.h&gt;using namespace std;void sort(int a[],int n)&#123; for(int d=n/2; d&gt;=1; d/=2) &#123; for(int i=d+1; i&lt;=n; i++) &#123; a[0] = a[i]; int j; for(j=i-d; j&gt;0&amp;&amp;a[0]&lt;a[j]; j-=d) &#123; a[j+d] = a[j]; &#125; a[j+d] = a[0]; &#125; &#125;&#125;int main()&#123; int a[100]; int n; cin&gt;&gt;n; for(int i=1; i&lt;=n; i++) cin&gt;&gt;a[i]; sort(a,n); for(int i=1; i&lt;=n; i++) cout&lt;&lt;a[i]&lt;&lt;\" \";&#125;#endif","categories":[],"tags":[{"name":"算法","slug":"算法","permalink":"http://yoursite.com/tags/算法/"}]},{"title":"Http状态码","slug":"Http状态码","date":"2019-06-24T15:41:23.000Z","updated":"2019-07-04T09:06:11.338Z","comments":true,"path":"2019/06/24/Http状态码/","link":"","permalink":"http://yoursite.com/2019/06/24/Http状态码/","excerpt":"","text":"—————————————-&gt;Http学习1.信息代码：1xx，2.成功代码：2xx，3.重定向：3xx，4.客户端错误：4xx，5.服务器错误：5xx ============================================================================= HTTP: Status 1xx (临时响应)表示临时响应并需要请求者继续执行操作的状态代码。详细代码及说明: HTTP: Status 100 (继续)-&gt;请求者应当继续提出请求。 服务器返回此代码表示已收到请求的第一部分，正在等待其余部分。HTTP: Status 101 (切换协议)-&gt;请求者已要求服务器切换协议，服务器已确认并准备切换。 HTTP Status 2xx (成功)表示成功处理了请求的状态代码;详细代码及说明: HTTP Status 200 (成功)-&gt; 服务器已成功处理了请求。 通常，这表示服务器提供了请求的网页。HTTP Status 201 (已创建)-&gt; 请求成功并且服务器创建了新的资源。HTTP Status 202 (已接受)-&gt; 服务器已接受请求，但尚未处理。HTTP Status 203 (非授权信息)-&gt; 服务器已成功处理了请求，但返回的信息可能来自另一来源。HTTP Status 204 (无内容)-&gt; 服务器成功处理了请求，但没有返回任何内容。HTTP Status 205 (重置内容)-&gt; 服务器成功处理了请求，但没有返回任何内容。HTTP Status 206 (部分内容)-&gt; 服务器成功处理了部分 GET 请求。 HTTP Status 3xx （重定向）常见的代码 300 （多种选择） 针对请求，服务器可执行多种操作。 服务器可根据请求者 (user agent) 选择一项操作，或提供操作列表供请求者选择。301 （永久移动） 请求的网页已永久移动到新位置。 服务器返回此响应（对 GET 或 HEAD 请求的响应）时，会自动将请求者转到新位置。302 （临时移动） 服务器目前从不同位置的网页响应请求，但请求者应继续使用原有位置来进行以后的请求。303 （查看其他位置） 请求者应当对不同的位置使用单独的 GET 请求来检索响应时，服务器返回此代码。304 （未修改） 自从上次请求后，请求的网页未修改过。 服务器返回此响应时，不会返回网页内容。305 （使用代理） 请求者只能使用代理访问请求的网页。 如果服务器返回此响应，还表示请求者应使用代理。307 （临时重定向） 服务器目前从不同位置的网页响应请求，但请求者应继续使用原有位置来进行以后的请求。 HTTP Status 4xx (请求错误)-&gt;这些状态代码表示请求可能出错，妨碍了服务器的处理。 详细代码说明:HTTP Status 400 （错误请求）-&gt;服务器不理解请求的语法。HTTP Status 401 （未授权）-&gt;请求要求身份验证。 对于需要登录的网页，服务器可能返回此响应。HTTP Status 403 （禁止）-&gt; 服务器拒绝请求。HTTP Status 404 （未找到）-&gt;服务器找不到请求的网页。HTTP Status 405 （方法禁用）-&gt;禁用请求中指定的方法。HTTP Status 406 （不接受）-&gt;无法使用请求的内容特性响应请求的网页。HTTP Status 407 （需要代理授权）-&gt;此状态代码与 401（未授权）类似，但指定请求者应当授权使用代理。HTTP Status 408 （请求超时）-&gt;服务器等候请求时发生超时。HTTP Status 409 （冲突）-&gt;服务器在完成请求时发生冲突。 服务器必须在响应中包含有关冲突的信息。HTTP Status 410 （已删除）-&gt; 如果请求的资源已永久删除，服务器就会返回此响应。HTTP Status 411 （需要有效长度）-&gt;服务器不接受不含有效内容长度标头字段的请求。HTTP Status 412 （未满足前提条件）-&gt;服务器未满足请求者在请求中设置的其中一个前提条件。HTTP Status 413 （请求实体过大）-&gt;服务器无法处理请求，因为请求实体过大，超出服务器的处理能力。HTTP Status 414 （请求的 URI 过长） 请求的 URI（通常为网址）过长，服务器无法处理。HTTP Status 415 （不支持的媒体类型）-&gt;请求的格式不受请求页面的支持。HTTP Status 416 （请求范围不符合要求）-&gt;如果页面无法提供请求的范围，则服务器会返回此状态代码。HTTP Status 417 （未满足期望值）-&gt;服务器未满足”期望”请求标头字段的要求。 HTTP Status 4xx (请求错误)-&gt;这些状态代码表示请求可能出错，妨碍了服务器的处理。 详细代码说明:HTTP Status 400 （错误请求）-&gt;服务器不理解请求的语法。HTTP Status 401 （未授权）-&gt;请求要求身份验证。 对于需要登录的网页，服务器可能返回此响应。HTTP Status 403 （禁止）-&gt; 服务器拒绝请求。HTTP Status 404 （未找到）-&gt;服务器找不到请求的网页。HTTP Status 405 （方法禁用）-&gt;禁用请求中指定的方法。HTTP Status 406 （不接受）-&gt;无法使用请求的内容特性响应请求的网页。HTTP Status 407 （需要代理授权）-&gt;此状态代码与 401（未授权）类似，但指定请求者应当授权使用代理。HTTP Status 408 （请求超时）-&gt;服务器等候请求时发生超时。HTTP Status 409 （冲突）-&gt;服务器在完成请求时发生冲突。 服务器必须在响应中包含有关冲突的信息。HTTP Status 410 （已删除）-&gt; 如果请求的资源已永久删除，服务器就会返回此响应。HTTP Status 411 （需要有效长度）-&gt;服务器不接受不含有效内容长度标头字段的请求。HTTP Status 412 （未满足前提条件）-&gt;服务器未满足请求者在请求中设置的其中一个前提条件。HTTP Status 413 （请求实体过大）-&gt;服务器无法处理请求，因为请求实体过大，超出服务器的处理能力。HTTP Status 414 （请求的 URI 过长） 请求的 URI（通常为网址）过长，服务器无法处理。HTTP Status 415 （不支持的媒体类型）-&gt;请求的格式不受请求页面的支持。HTTP Status 416 （请求范围不符合要求）-&gt;如果页面无法提供请求的范围，则服务器会返回此状态代码。HTTP Status 417 （未满足期望值）-&gt;服务器未满足”期望”请求标头字段的要求。 HTTP Status 5xx （服务器错误）-&gt;这些状态代码表示服务器在尝试处理请求时发生内部错误。 这些错误可能是服务器本身的错误，而不是请求出错。 代码详细及说明:HTTP Status 500 （服务器内部错误）-&gt;服务器遇到错误，无法完成请求。HTTP Status 501 （尚未实施）-&gt;服务器不具备完成请求的功能。 例如，服务器无法识别请求方法时可能会返回此代码。HTTP Status 502 （错误网关）-&gt;服务器作为网关或代理，从上游服务器收到无效响应。HTTP Status 503 （服务不可用）-&gt; 服务器目前无法使用（由于超载或停机维护）。 通常，这只是暂时状态。HTTP Status 504 （网关超时）-&gt;服务器作为网关或代理，但是没有及时从上游服务器收到请求。HTTP Status 505 （HTTP 版本不受支持）-&gt; 服务器不支持请求中所用的 HTTP 协议版本。","categories":[],"tags":[{"name":"计算机网络","slug":"计算机网络","permalink":"http://yoursite.com/tags/计算机网络/"}]},{"title":"网络端口号","slug":"端口号","date":"2019-06-24T07:01:10.000Z","updated":"2019-06-24T15:54:36.419Z","comments":true,"path":"2019/06/24/端口号/","link":"","permalink":"http://yoursite.com/2019/06/24/端口号/","excerpt":"","text":"21/tcp FTP 文件传输协议22/tcp SSH 安全登录、文件传送(SCP)和端口重定向23/tcp Telnet 不安全的文本传送25/tcp SMTP Simple Mail Transfer Protocol (E-mail)69/udp TFTP Trivial File Transfer Protocol79/tcp finger Finger80/tcp HTTP 超文本传送协议 (WWW)88/tcp Kerberos Authenticating agent110/tcp POP3 Post Office Protocol (E-mail)113/tcp ident old identification server system119/tcp NNTP used for usenet newsgroups220/tcp IMAP3443/tcp HTTPS used for securely transferring web pages端口：0服务：Reserved说明：通常用于分析操作系统。这一方法能够工作是因为在一些系统中“0”是无效端口，当你试图使用通常的闭合端口连接它时将产生不同的结果。一种典型的扫描，使用IP地址为0.0.0.0，设置ACK位并在以太网层广播。 端口：1服务：tcpmux说明：这显示有人在寻找SGI Irix机器。Irix是实现tcpmux的主要提供者，默认情况下tcpmux在这种系统中被打开。Irix机器在发布是含有几个默认的无密码的帐户，如：IP、GUEST UUCP、NUUCP、DEMOS 、TUTOR、DIAG、OUTOFBOX等。许多管理员在安装后忘记删除这些帐户。因此HACKER在INTERNET上搜索tcpmux并利用这些帐户。 端口：7服务：Echo说明：能看到许多人搜索Fraggle放大器时，发送到X.X.X.0和X.X.X.255的信息。 端口：19服务：Character Generator说明：这是一种仅仅发送字符的服务。UDP版本将会在收到UDP包后回应含有垃圾字符的包。TCP连接时会发送含有垃圾字符的数据流直到连接关闭。HACKER利用IP欺骗可以发动DoS攻击。伪造两个chargen服务器之间的UDP包。同样Fraggle DoS攻击向目标地址的这个端口广播一个带有伪造受害者IP的数据包，受害者为了回应这些数据而过载。 端口：21服务：FTP说明：FTP服务器所开放的端口，用于上传、下载。最常见的攻击者用于寻找打开anonymous的FTP服务器的方法。这些服务器带有可读写的目录。木马Doly Trojan、Fore、Invisible FTP、WebEx、WinCrash和Blade Runner所开放的端口。 端口：22服务：Ssh说明：PcAnywhere建立的TCP和这一端口的连接可能是为了寻找ssh。这一服务有许多弱点，如果配置成特定的模式，许多使用RSAREF库的版本就会有不少的漏洞存在。 端口：23服务：Telnet说明：远程登录，入侵者在搜索远程登录UNIX的服务。大多数情况下扫描这一端口是为了找到机器运行的操作系统。还有使用其他技术，入侵者也会找到密码。木马Tiny Telnet Server就开放这个端口。 端口：25服务：SMTP说明：SMTP服务器所开放的端口，用于发送邮件。入侵者寻找SMTP服务器是为了传递他们的SPAM。入侵者的帐户被关闭，他们需要连接到高带宽的E-MAIL服务器上，将简单的信息传递到不同的地址。木马Antigen、Email Password Sender、Haebu Coceda、Shtrilitz Stealth、WinPC、WinSpy都开放这个端口。 端口：31服务：MSG Authentication说明：木马Master Paradise、Hackers Paradise开放此端口。 端口：42服务：WINS Replication说明：WINS复制 端口：53服务：Domain Name Server（DNS）说明：DNS服务器所开放的端口，入侵者可能是试图进行区域传递（TCP），欺骗DNS（UDP）或隐藏其他的通信。因此防火墙常常过滤或记录此端口。端口：67服务：Bootstrap Protocol Server说明：通过DSL和Cable modem的防火墙常会看见大量发送到广播地址255.255.255.255的数据。这些机器在向DHCP服务器请求一个地址。HACKER常进入它们，分配一个地址把自己作为局部路由器而发起大量中间人（man-in-middle）攻击。客户端向68端口广播请求配置，服务器向67端口广播回应请求。这种回应使用广播是因为客户端还不知道可以发送的IP地址。 端口：69服务：Trival File Transfer说明：许多服务器与bootp一起提供这项服务，便于从系统下载启动代码。但是它们常常由于错误配置而使入侵者能从系统中窃取任何 文件。它们也可用于系统写入文件。 端口：79服务：Finger Server说明：入侵者用于获得用户信息，查询操作系统，探测已知的缓冲区溢出错误，回应从自己机器到其他机器Finger扫描。 端口：80服务：HTTP说明：用于网页浏览。木马Executor开放此端口。 端口：99服务：gram Relay说明：后门程序ncx99开放此端口。 端口：102服务：Message transfer agent(MTA)-X.400 over TCP/IP说明：消息传输代理。 端口：109服务：Post Office Protocol -Version3说明：POP3服务器开放此端口，用于接收邮件，客户端访问服务器端的邮件服务。POP3服务有许多公认的弱点。关于用户名和密码交 换缓冲区溢出的弱点至少有20个，这意味着入侵者可以在真正登陆前进入系统。成功登陆后还有其他缓冲区溢出错误。 端口：110服务：SUN公司的RPC服务所有端口说明：常见RPC服务有rpc.mountd、NFS、rpc.statd、rpc.csmd、rpc.ttybd、amd等 端口：113服务：Authentication Service说明：这是一个许多计算机上运行的协议，用于鉴别TCP连接的用户。使用标准的这种服务可以获得许多计算机的信息。但是它可作为许多服务的记录器，尤其是FTP、POP、IMAP、SMTP和IRC等服务。通常如果有许多客户通过防火墙访问这些服务，将会看到许多这个端口的连接请求。记住，如果阻断这个端口客户端会感觉到在防火墙另一边与E-MAIL服务器的缓慢连接。许多防火墙支持TCP连接的阻断过程中发回RST。这将会停止缓慢的连接。端口：119服务：Network News Transfer Protocol说明：NEWS新闻组传输协议，承载USENET通信。这个端口的连接通常是人们在寻找USENET服务器。多数ISP限制，只有他们的客户才能访问他们的新闻组服务器。打开新闻组服务器将允许发/读任何人的帖子，访问被限制的新闻组服务器，匿名发帖或发送SPAM。 端口：135服务：Location Service说明：Microsoft在这个端口运行DCE RPC end-point mapper为它的DCOM服务。这与UNIX 111端口的功能很相似。使用DCOM和RPC的服务利用计算机上的end-point mapper注册它们的位置。远端客户连接到计算机时，它们查找end-point mapper找到服务的位置。HACKER扫描计算机的这个端口是为了找到这个计算机上运行Exchange Server吗？什么版本？还有些DOS攻击直接针对这个端口。 端口：137、138、139服务：NETBIOS Name Service说明：其中137、138是UDP端口，当通过网上邻居传输文件时用这个端口。而139端口：通过这个端口进入的连接试图获得NetBIOS/SMB服务。这个协议被用于windows文件和打印机共享和SAMBA。还有WINS Regisrtation也用它。 端口：143服务：Interim Mail Access Protocol v2说明：和POP3的安全问题一样，许多IMAP服务器存在有缓冲区溢出漏洞。记住：一种LINUX蠕虫（admv0rm）会通过这个端口繁殖，因此许多这个端口的扫描来自不知情的已经被感染的用户。当REDHAT在他们的LINUX发布版本中默认允许IMAP后，这些漏洞变的很流行。这一端口还被用于IMAP2，但并不流行。 端口：161服务：SNMP说明：SNMP允许远程管理设备。所有配置和运行信息的储存在数据库中，通过SNMP可获得这些信息。许多管理员的错误配置将被暴露在Internet。Cackers将试图使用默认的密码public、private访问系统。他们可能会试验所有可能的组合。SNMP包可能会被错误的指向用户的网络。 端口：177服务：X Display Manager Control Protocol说明：许多入侵者通过它访问X-windows操作台，它同时需要打开6000端口。 端口：389服务：LDAP、ILS说明：轻型目录访问协议和NetMeeting Internet Locator Server共用这一端口。 端口：443服务：Https说明：网页浏览端口，能提供加密和通过安全端口传输的另一种HTTP。 端口：456服务：[NULL]说明：木马HACKERS PARADISE开放此端口。 端口：513服务：Login,remote login说明：是从使用cable modem或DSL登陆到子网中的UNIX计算机发出的广播。这些人为入侵者进入他们的系统提供了信息。 端口：544服务：[NULL]说明：kerberos kshell 端口：548服务：Macintosh,File Services(AFP/IP)说明：Macintosh,文件服务。 端口：553服务：CORBA IIOP （UDP）说明：使用cable modem、DSL或VLAN将会看到这个端口的广播。CORBA是一种面向对象的RPC系统。入侵者可以利用这些信息进入系统。 端口：555服务：DSF说明：木马PhAse1.0、Stealth Spy、IniKiller开放此端口。端口：568服务：Membership DPA说明：成员资格 DPA。 端口：569服务：Membership MSN说明：成员资格 MSN。 端口：635服务：mountd说明：Linux的mountd Bug。这是扫描的一个流行BUG。大多数对这个端口的扫描是基于UDP的，但是基于TCP的mountd有所增加（mountd同时运行于两个端口）。记住mountd可运行于任何端口（到底是哪个端口，需要在端口111做portmap查询），只是Linux默认端口是635，就像NFS通常运行于2049端口。 端口：636服务：LDAP说明：SSL（Secure Sockets layer） 端口：666服务：Doom Id Software说明：木马Attack FTP、Satanz Backdoor开放此端口 端口：993服务：IMAP说明：SSL（Secure Sockets layer） 端口：1001、1011服务：[NULL]说明：木马Silencer、WebEx开放1001端口。木马Doly Trojan开放1011端口。 端口：1024服务：Reserved说明：它是动态端口的开始，许多程序并不在乎用哪个端口连接网络，它们请求系统为它们分配下一个闲置端口。基于这一点分配从端口1024开始。这就是说第一个向系统发出请求的会分配到1024端口。你可以重启机器，打开Telnet，再打开一个窗口运行natstat -a 将会看到Telnet被分配1024端口。还有SQL session也用此端口和5000端口。 端口：1025、1033服务：1025：network blackjack 1033：[NULL]说明：木马netspy开放这2个端口。 端口：1080服务：SOCKS说明：这一协议以通道方式穿过防火墙，允许防火墙后面的人通过一个IP地址访问INTERNET。理论上它应该只允许内部的通信向外到达INTERNET。但是由于错误的配置，它会允许位于防火墙外部的攻击穿过防火墙。WinGate常会发生这种错误，在加入IRC聊天室时常会看到这种情况。 端口：1170服务：[NULL]说明：木马Streaming Audio Trojan、Psyber Stream Server、Voice开放此端口。 端口：1234、1243、6711、6776服务：[NULL]说明：木马SubSeven2.0、Ultors Trojan开放1234、6776端口。木马SubSeven1.0/1.9开放1243、6711、6776端口。 端口：1245服务：[NULL]说明：木马Vodoo开放此端口。 端口：1433服务：SQL说明：Microsoft的SQL服务开放的端口。 端口：1492服务：stone-design-1说明：木马FTP99CMP开放此端口。 端口：1500服务：RPC client fixed port session queries说明：RPC客户固定端口会话查询 端口：1503服务：NetMeeting T.120说明：NetMeeting T.120 端口：1524服务：ingress说明：许多攻击脚本将安装一个后门SHELL于这个端口，尤其是针对SUN系统中Sendmail和RPC服务漏洞的脚本。如果刚安装了防火墙就看到在这个端口上的连接企图，很可能是上述原因。可以试试Telnet到用户的计算机上的这个端口，看看它是否会给你一个SHELL。连接到600/pcserver也存在这个问题。 端口：1600服务：issd说明：木马Shivka-Burka开放此端口。 端口：1720服务：NetMeeting说明：NetMeeting H.233 call Setup。 端口：1731服务：NetMeeting Audio Call Control说明：NetMeeting音频调用控制。 端口：1807服务：[NULL]说明：木马SpySender开放此端口。 端口：1981服务：[NULL]说明：木马ShockRave开放此端口。 端口：1999服务：cisco identification port说明：木马BackDoor开放此端口。 端口：2000服务：[NULL]说明：木马GirlFriend 1.3、Millenium 1.0开放此端口。 端口：2001服务：[NULL]说明：木马Millenium 1.0、Trojan Cow开放此端口。 端口：2023服务：xinuexpansion 4说明：木马Pass Ripper开放此端口。 端口：2049服务：NFS说明：NFS程序常运行于这个端口。通常需要访问Portmapper查询这个服务运行于哪个端口。 端口：2115服务：[NULL]说明：木马Bugs开放此端口。 端口：2140、3150服务：[NULL]说明：木马Deep Throat 1.0/3.0开放此端口。 端口：2500服务：RPC client using a fixed port session replication说明：应用固定端口会话复制的RPC客户","categories":[],"tags":[{"name":"计算机网络","slug":"计算机网络","permalink":"http://yoursite.com/tags/计算机网络/"}]},{"title":"天津之行","slug":"天津之行","date":"2018-10-07T17:25:31.000Z","updated":"2018-10-08T09:33:46.805Z","comments":true,"path":"2018/10/08/天津之行/","link":"","permalink":"http://yoursite.com/2018/10/08/天津之行/","excerpt":"","text":"2018年的十一假期过去了，明天又要开始上课了，不对，是今天。忙碌了一个暑假做了小app，终于提交了小作品，哈！终于有了一个小假期，安排一手，顶着人流高峰，出去转一转。天津，怎么说，感觉那边的方言特别的有味道呢？对！就是说快板的味道，媒体在无形中给留下的影响还是蛮大的嘛。怎么说，在电视机旁看一场相声，真的不如来一场现场的来的有感觉！还有嘛，就是躺在秋天的草坪上面，旁边放着音乐，体会时间的悠闲哈！简单放两张图纪念一下。传说中的天津之眼，架在桥上的摩天轮真的有些许艺术感。","categories":[],"tags":[{"name":"杂谈","slug":"杂谈","permalink":"http://yoursite.com/tags/杂谈/"}]},{"title":"next主题","slug":"主题","date":"2018-05-11T14:42:36.000Z","updated":"2018-05-13T05:56:46.918Z","comments":true,"path":"2018/05/11/主题/","link":"","permalink":"http://yoursite.com/2018/05/11/主题/","excerpt":"","text":"这两天比较了yilia和next主题，最后还是选择了自我感觉比较酷next主题，从这中间也走了一些坑。1.克隆下来的主题，从git上克隆下来了一个不是最新版本的就是比较伤的事情了，突然发现主题的语言变成了德文–？看到git日志才发现最新的git版本的url。2.还有就是最初按照next官方文档配置的目录..发现官方文档也好久没有更新了，目录中的about、tags等都需要手动配置，拿about说一下，hexo new post”about”，然后在md里添加type: “about”，记得有空格啊。","categories":[],"tags":[{"name":"杂谈","slug":"杂谈","permalink":"http://yoursite.com/tags/杂谈/"}]},{"title":"Git和Markdown的小用法","slug":"Git+Markdown","date":"2018-03-22T15:24:01.000Z","updated":"2018-05-11T15:12:57.530Z","comments":true,"path":"2018/03/22/Git+Markdown/","link":"","permalink":"http://yoursite.com/2018/03/22/Git+Markdown/","excerpt":"","text":"简单的用于博客的指令：hexo new post “the name of the file”hexo g 部署hexo shexo s –debughexo dhexo d -g Markdown1.标题设置： #字符用于控制标题大小 （一级也就是一个#最大）2.块注释：（blockquote） 通过在文字开头添加“&gt;”表示块注释 3.斜体： 将需要设置为斜体的文字两端使用1个星号 或者 ““夹起来 @zeroker4.粗体：将需要设置为斜体的文字两端使用2个”*”或者”“夹起来 @zeroker5.链接：内联方式：This is an [注释] (url).6.图片：! [alt text] [id]","categories":[],"tags":[{"name":"杂谈","slug":"杂谈","permalink":"http://yoursite.com/tags/杂谈/"}]},{"title":"博客搭建教程","slug":"教程","date":"2017-04-20T12:53:32.000Z","updated":"2018-05-11T14:15:14.379Z","comments":true,"path":"2017/04/20/教程/","link":"","permalink":"http://yoursite.com/2017/04/20/教程/","excerpt":"","text":"exciting AND 因吹斯汀 。点击-&gt;教程点击-&gt;markdow语法点击-&gt;window10快捷键 Open the world–&gt;topcoderopen the world–&gt;codeforces","categories":[],"tags":[{"name":"杂谈","slug":"杂谈","permalink":"http://yoursite.com/tags/杂谈/"}]}]}